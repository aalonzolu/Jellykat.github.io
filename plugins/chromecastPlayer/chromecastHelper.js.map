{"version":3,"sources":["plugins/chromecastPlayer/chromecastHelper.js"],"names":["define","_exports","_events","Object","defineProperty","value","getServerAddress","default","_interopRequireDefault","obj","__esModule","protocols","linkRegExp","RegExp","protocolRegExp","ensureProtocol","url","match","LinkParser","parse","text","links","exec","console","debug","txt","pos","index","len","length","push","window","cache","apiClient","serverAddress","isValidIpAddress","address","isLocalIpAddress","toLowerCase","includes","Promise","resolve","cachedValue","getCachedValue","key","Date","getTime","time","getEndpointInfo","then","endpoint","IsInNetwork","getPublicSystemInfo","info","localAddress","LocalAddress","addToCache","clearCache","events","on","ConnectionManager","_default"],"mappings":"AAAAA,OAAO,CAAC,UAAW,WAAW,SAAUC,SAAUC,SAChD,aAEAC,OAAOC,eAAeH,SAAU,aAAc,CAC5CI,OAAO,IAETJ,SAASK,iBAAmBA,iBAC5BL,SAASM,aAAU,EAPrBL,QAUE,SAASM,uBAAuBC,KAAO,OAAOA,KAAOA,IAAIC,WAAaD,IAAM,CAAEF,QAASE,KAVzFD,CAAAN,SAWA,WA0BI,IAAMS,UAAY,qCA4EZC,WAAaC,OAhDf,wnDAgDwC,MAEtCC,eAAiBD,OAAO,IAAMF,UAAW,KAG/C,SAASI,eAAeC,KAIpB,OAHKA,IAAIC,MAAMH,kBACXE,IAAM,UAAYA,KAEfA,IAIX,IAAME,WAAa,CACfC,MAAO,SAAAA,MAAUC,MAKb,IAJA,IACIH,MADEI,MAAQ,GAIPJ,MAAQL,WAAWU,KAAKF,OAAO,CAClCG,QAAQC,MAAMP,OACd,IAAMQ,IAAMR,MAAM,GACZS,IAAMT,MAAMU,MACZC,IAAMH,IAAII,OACVb,IAAMD,eAAeK,MAC3BC,MAAMS,KAAK,CAAEJ,IAAOA,IAAKN,KAAQK,IAAKG,IAAOA,IAAKZ,IAAOA,MAG7D,OAAOK,QAKfU,OAAOb,WAAaA,WAvIxB,GA0IA,IAAIc,MAAQ,GAuBL,SAAS1B,iBAAiB2B,WAC7B,IAAMC,cAAgBD,UAAUC,gBAEhC,GAvBJ,SAASC,iBAAiBC,SAGtB,OAAuB,GAFTlB,WAAWC,MAAMiB,SAElBP,OAoBTM,CAAiBD,iBAhBzB,SAASG,iBAAiBD,SAGtB,SAFAA,QAAUA,QAAQE,eAENC,SAAS,gBAGjBH,QAAQG,SAAS,aAUmBF,CAAiBH,eACrD,OAAOM,QAAQC,QAAQP,eAG3B,IAAMQ,YAkCV,SAASC,eAAeC,KACpB,IAAMnC,IAAMuB,MAAMY,KAElB,GAAInC,MAAQ,IAAIoC,MAAOC,UAAYrC,IAAIsC,KAAQ,KAC3C,OAAOtC,IAAIJ,MAGf,OAAO,KAzCasC,CAAeT,eACnC,OAAIQ,YACOF,QAAQC,QAAQC,aAGpBT,UAAUe,kBAAkBC,MAAK,SAAUC,UAC9C,OAAIA,SAASC,YACFlB,UAAUmB,sBAAsBH,MAAK,SAAUI,MAClD,IAAIC,aAAeD,KAAKE,aAMxB,OALKD,eACD/B,QAAQC,MAAM,+DACd8B,aAAepB,eAEnBsB,WAAWtB,cAAeoB,cACnBA,iBAGXE,WAAWtB,cAAeA,eACnBA,kBAKnB,SAASuB,aACLzB,MAAQ,GAGZ,SAASwB,WAAWZ,IAAKvC,OACrB2B,MAAMY,KAAO,CACTvC,MAAOA,MACP0C,MAAM,IAAIF,MAAOC,WAczBY,QAAAA,QAAOC,GAAGC,kBAAmB,oBAAqBH,YAClDC,QAAAA,QAAOC,GAAGC,kBAAmB,qBAAsBH,YA5BjD,IAAII,SA8BS,CACXvD,iBAAkBA,kBA5BpBL,SAASM,QAAUsD","file":"chromecastHelper.js","sourcesContent":["import events from 'events';\n\n// LinkParser\n//\n// https://github.com/ravisorg/LinkParser\n//\n// Locate and extract almost any URL within a string. Handles protocol-less domains, IPv4 and\n// IPv6, unrecognised TLDs, and more.\n//\n// This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// http://creativecommons.org/licenses/by-sa/4.0/\n(function () {\n    // Original URL regex from the Android android.text.util.Linkify function, found here:\n    // http://stackoverflow.com/a/19696443\n    //\n    // However there were problems with it, most probably related to the fact it was\n    // written in 2007, and it's been highly modified.\n    //\n    // 1) I didn't like the fact that it was tied to specific TLDs, since new ones\n    // are being added all the time it wouldn't be reasonable to expect developer to\n    // be continually updating their regular expressions.\n    //\n    // 2) It didn't allow unicode characters in the domains which are now allowed in\n    // many languages, (including some IDN TLDs). Again these are constantly being\n    // added to and it doesn't seem reasonable to hard-code them. Note this ended up\n    // not being possible in standard JS due to the way it handles multibyte strings.\n    // It is possible using XRegExp, however a big performance hit results. Disabled\n    // for now.\n    //\n    // 3) It didn't allow for IPv6 hostnames\n    // IPv6 regex from http://stackoverflow.com/a/17871737\n    //\n    // 4) It was very poorly commented\n    //\n    // 5) It wasn't as smart as it could have been about what should be part of a\n    // URL and what should be part of human language.\n\n    const protocols = '(?:(?:http|https|rtsp|ftp):\\\\/\\\\/)';\n    const credentials = \"(?:(?:[a-z0-9\\\\$\\\\-\\\\_\\\\.\\\\+\\\\!\\\\*\\\\'\\\\(\\\\)\\\\,\\\\;\\\\?\\\\&\\\\=]|(?:\\\\%[a-f0-9]{2})){1,64}\" // username (1-64 normal or url escaped characters)\n        + \"(?:\\\\:(?:[a-z0-9\\\\$\\\\-\\\\_\\\\.\\\\+\\\\!\\\\*\\\\'\\\\(\\\\)\\\\,\\\\;\\\\?\\\\&\\\\=]|(?:\\\\%[a-f0-9]{2})){1,25})?\" // followed by optional password (: + 1-25 normal or url escaped characters)\n        + '\\\\@)';\n\n    // IPv6 Regex http://forums.intermapper.com/viewtopic.php?t=452\n    // by Dartware, LLC is licensed under a Creative Commons Attribution-ShareAlike 3.0 Unported License\n    // http://intermapper.com/\n    const ipv6 = '('\n        + '(([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))'\n        + '|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))'\n        + '|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))'\n        + '|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))'\n        + '|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))'\n        + '|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))'\n        + '|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))'\n        + '|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))'\n        + ')(%.+)?';\n\n    const ipv4 = '(?:25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9])\\\\.'\n        + '(?:25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9]|0)\\\\.'\n        + '(?:25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9]|0)\\\\.'\n        + '(?:25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}|[1-9][0-9]|[0-9])';\n\n    // This would have been a lot cleaner if JS RegExp supported conditionals...\n    const linkRegExpString =\n\n        // begin match for protocol / username / password / host\n        '(?:'\n\n        // ============================\n        // If we have a recognized protocol at the beginning of the URL, we're\n        // more relaxed about what we accept, because we assume the user wants\n        // this to be a URL, and we're not accidentally matching human language\n        + protocols + '?'\n\n        // optional username:password@\n        + credentials + '?'\n\n        // IP address (both v4 and v6)\n        + '(?:'\n\n        // IPv6\n        + ipv6\n\n        // IPv4\n        + '|' + ipv4\n\n        + ')'\n\n        // end match for protocol / username / password / host\n        + ')'\n\n        // optional port number\n        + '(?:\\\\:\\\\d{1,5})?'\n\n        // plus optional path and query params (no unicode allowed here?)\n        + '(?:'\n        + '\\\\/(?:'\n        // some characters we'll accept because it's unlikely human language\n        // would use them after a URL unless they were part of the url\n        + '(?:[a-z0-9\\\\/\\\\@\\\\&\\\\#\\\\~\\\\*\\\\_\\\\-\\\\+])'\n        + '|(?:\\\\%[a-f0-9]{2})'\n        // some characters are much more likely to be used AFTER a url and\n        // were not intended to be included in the url itself. Mostly end\n        // of sentence type things. It's also likely that the URL would\n        // still work if any of these characters were missing from the end\n        // because we parsed it incorrectly. For these characters to be accepted\n        // they must be followed by another character that we're reasonably\n        // sure is part of the url\n        + \"|(?:[\\\\;\\\\?\\\\:\\\\.\\\\!\\\\'\\\\(\\\\)\\\\,\\\\=]+(?=(?:[a-z0-9\\\\/\\\\@\\\\&\\\\#\\\\~\\\\*\\\\_\\\\-\\\\+])|(?:\\\\%[a-f0-9]{2})))\"\n        + ')*'\n        + '|\\\\b|\\$'\n        + ')';\n\n    // regex = XRegExp(regex,'gi');\n    const linkRegExp = RegExp(linkRegExpString, 'gi');\n\n    const protocolRegExp = RegExp('^' + protocols, 'i');\n\n    // if url doesn't begin with a known protocol, add http by default\n    function ensureProtocol(url) {\n        if (!url.match(protocolRegExp)) {\n            url = 'http://' + url;\n        }\n        return url;\n    }\n\n    // look for links in the text\n    const LinkParser = {\n        parse: function (text) {\n            const links = [];\n            let match;\n\n            // eslint-disable-next-line no-cond-assign\n            while (match = linkRegExp.exec(text)) {\n                console.debug(match);\n                const txt = match[0];\n                const pos = match.index;\n                const len = txt.length;\n                const url = ensureProtocol(text);\n                links.push({ 'pos': pos, 'text': txt, 'len': len, 'url': url });\n            }\n\n            return links;\n        }\n\n    };\n\n    window.LinkParser = LinkParser;\n})();\n\nlet cache = {};\n\n// TODO: Replace with isIP (https://www.npmjs.com/package/is-ip)\nfunction isValidIpAddress(address) {\n    const links = LinkParser.parse(address);\n\n    return links.length == 1;\n}\n\n// TODO: Add IPv6 support. Potentially replace with isLocalhost (https://www.npmjs.com/package/is-localhost-ip)\nfunction isLocalIpAddress(address) {\n    address = address.toLowerCase();\n\n    if (address.includes('127.0.0.1')) {\n        return true;\n    }\n    if (address.includes('localhost')) {\n        return true;\n    }\n\n    return false;\n}\n\nexport function getServerAddress(apiClient) {\n    const serverAddress = apiClient.serverAddress();\n\n    if (isValidIpAddress(serverAddress) && !isLocalIpAddress(serverAddress)) {\n        return Promise.resolve(serverAddress);\n    }\n\n    const cachedValue = getCachedValue(serverAddress);\n    if (cachedValue) {\n        return Promise.resolve(cachedValue);\n    }\n\n    return apiClient.getEndpointInfo().then(function (endpoint) {\n        if (endpoint.IsInNetwork) {\n            return apiClient.getPublicSystemInfo().then(function (info) {\n                let localAddress = info.LocalAddress;\n                if (!localAddress) {\n                    console.debug('No valid local address returned, defaulting to external one');\n                    localAddress = serverAddress;\n                }\n                addToCache(serverAddress, localAddress);\n                return localAddress;\n            });\n        } else {\n            addToCache(serverAddress, serverAddress);\n            return serverAddress;\n        }\n    });\n}\n\nfunction clearCache() {\n    cache = {};\n}\n\nfunction addToCache(key, value) {\n    cache[key] = {\n        value: value,\n        time: new Date().getTime()\n    };\n}\n\nfunction getCachedValue(key) {\n    const obj = cache[key];\n\n    if (obj && (new Date().getTime() - obj.time) < 180000) {\n        return obj.value;\n    }\n\n    return null;\n}\n\nevents.on(ConnectionManager, 'localusersignedin', clearCache);\nevents.on(ConnectionManager, 'localusersignedout', clearCache);\n\nexport default {\n    getServerAddress: getServerAddress\n};\n"]}