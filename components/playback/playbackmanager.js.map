{"version":3,"sources":["components/playback/playbackmanager.js"],"names":["define","_require","_exports","_events","_datetime","_appSettings","_itemHelper","_pluginManager","_playQueueManager","userSettings","_globalize","_connectionManager","_loading","_apphost","_screenfull","_interopRequireDefault","obj","__esModule","default","_typeof","Symbol","iterator","constructor","prototype","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_getRequireWildcardCache","WeakMap","cache","_interopRequireWildcard","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","hasOwnProperty","call","desc","set","enableLocalPlaylistManagement","player","getPlaylist","isLocalPlayer","reportPlayback","playbackManagerInstance","state","reportPlaylist","serverId","method","progressEventName","info","assign","PlayState","ItemId","NowPlayingItem","Id","EventName","addPlaylistToPlaybackReport","NowPlayingQueue","getPlaylistSync","_currentPlayer","map","itemInfo","PlaylistItemId","ServerId","connectionManager","getApiClient","then","events","trigger","normalizeName","t","toLowerCase","replace","getItemsForPlayback","query","apiClient","Ids","split","itemId","getItem","getCurrentUserId","item","Items","TotalRecordCount","Limit","Fields","ExcludeLocationTypes","EnableTotalRecordCount","CollapseBoxSetItems","getItems","getMimeType","type","container","getParam","name","url","results","RegExp","exec","decodeURIComponent","isAutomaticPlayer","isServerItem","getIntros","firstItem","options","startPositionTicks","startIndex","fullscreen","enableIntros","MediaType","Type","Status","enableCinemaMode","Promise","resolve","result","err","getAudioMaxValues","deviceProfile","maxAudioSampleRate","maxAudioBitDepth","maxAudioBitrate","CodecProfiles","codecProfile","Conditions","condition","Condition","Property","Value","value","startingPlaySession","Date","getTime","getAudioStreamUrl","transcodingProfile","directPlayContainers","maxBitrate","startPosition","getUrl","UserId","DeviceId","deviceId","MaxStreamingBitrate","Container","TranscodingContainer","TranscodingProtocol","Protocol","AudioCodec","MaxAudioSampleRate","MaxAudioBitDepth","api_key","accessToken","PlaySessionId","StartTimeTicks","EnableRedirection","EnableRemoteMedia","appHost","supports","getAudioStreamUrlFromDeviceProfile","TranscodingProfiles","filter","p","Context","DirectPlayProfiles","maxValues","setStreamUrls","items","getStreamUrls","audioTranscodingProfile","audioDirectPlayContainers","streamUrls","streamUrl","itemHelper","isLocalItem","push","PresetMediaSource","StreamUrl","MediaStreams","RunTimeTicks","getPlaybackInfo","isPlayback","mediaSourceId","audioStreamIndex","subtitleStreamIndex","liveStreamId","enableDirectPlay","enableDirectStream","allowVideoStreamCopy","allowAudioStreamCopy","MediaSources","IsPlayback","AutoOpenLiveStream","AudioStreamIndex","SubtitleStreamIndex","EnableDirectPlay","EnableDirectStream","AllowVideoStreamCopy","AllowAudioStreamCopy","MediaSourceId","LiveStreamId","enableMediaProbe","EnableMediaProbe","supportsPlayMethod","getDirectPlayProtocols","DirectPlayProtocols","supportsDirectPlay","mediaSource","isFolderRip","VideoType","SupportsDirectPlay","IsRemote","RequiredHttpHeaders","SupportsDirectStream","SupportsTranscoding","isHostReachable","getEndpointInfo","endpointInfo","IsInNetwork","IsLocal","path","Path","indexOf","reject","_resolve","_reject","imported","filesystem","validatePlaybackInfoResult","instance","ErrorCode","showPlaybackInfoErrorMessage","errorCode","playNextTrack","_ref","alert","text","globalize","translate","title","nextTrack","normalizePlayOptions","playOptions","displayPlayerIndividually","createTarget","id","playerName","playableMediaTypes","canPlayMediaType","supportedCommands","getSupportedCommands","getPlayerTargets","getTargets","sortPlayerTargets","a","b","aVal","bVal","toString","localeCompare","_default","PlaybackManager","_classCallCheck","Constructor","TypeError","this","currentTargetInfo","self","players","currentPairingId","_playNextAfterEnded","brightnessOsdLoaded","playerStates","getSubtitleStream","index","subtitleTracks","s","Index","removeCurrentPlayer","previousPlayer","setCurrentPlayerInternal","targetInfo","previousTargetInfo","Error","console","debug","JSON","stringify","endPlayerUpdates","beginPlayerUpdates","triggerPlayerChange","newPlayer","newTarget","getSavedMaxStreamingBitrate","mediaType","currentApiClient","getSavedEndpointInfo","appSettings","maxStreamingBitrate","getDeliveryMethod","subtitleStream","DeliveryMethod","IsExternal","canPlayerSeek","getPlayerData","streamInfo","seekable","playMethod","duration","changeStream","ticks","params","currentTime","parseInt","lastMediaInfoQuery","playSessionId","currentItem","getDeviceProfile","isRetry","currentMediaSource","getMaxStreamingBitrate","currentPlayOptions","createStreamInfo","changeStreamToUrl","newPositionTicks","playerData","isChangingStream","stopActiveEncodings","afterSetSrc","setSrcIntoPlayer","play","started","ended","sendProgressUpdate","e","onPlaybackError","translateItemsForPlayback","ids","sort","promise","queryOptions","ChannelId","ParentId","SortBy","shuffle","ArtistIds","Filters","Recursive","MediaTypes","GenreIds","IsFolder","mergePlaybackQueries","obj1","obj2","filters","join","getPlayer","supportsProgress","getCurrentUser","user","Configuration","EnableNextEpisodeAutoPlay","SeriesId","getEpisodes","IsVirtualUnaired","IsMissing","episodesResult","foundItem","getCurrentTicks","playerTime","Math","floor","transcodingOffsetTicks","playWithIntros","playStartIndex","playOther","loading","hide","introsResult","introPlayOptions","introItems","truncatePlayOptions","concat","playInternal","setPlaylist","setPlaylistState","playlistItemId","isNaN","onPlaybackStartedFn","IsPlaceHolder","isFirstItem","runInterceptors","interceptors","pluginManager","ofType","order","runNextPrePlay","intercept","show","onBitrateDetectionFailure","playAfterBitrateDetect","enableAutomaticBitrateDetection","detectBitrate","bitrate","onInterceptorRejection","destroyPlayer","destroy","activePlayer","onPlaybackChanging","newItem","getPlayerState","stopPlaybackProgressTimer","unbindStopped","off","onPlaybackStopped","stop","bindStopped","nextItem","nextMediaType","all","responses","sendPlaybackListToPlayer","getPlaybackMediaSource","onPlaybackStarted","setTimeout","createStreamInfoFromUrlItem","Url","textTracks","mediaUrl","contentType","directOptions","playerStartPositionTicks","mediaSourceContainer","Static","ETag","Tag","prefix","TranscodingUrl","TranscodingSubProtocol","resultInfo","mimeType","getTextTracks","tracks","Name","backdropUrl","backdropImageUrl","maxWidth","width","maxHeight","height","quality","BackdropImageTags","tag","getScaledImageUrl","ParentBackdropImageTags","ParentBackdropItemId","textStreams","textStream","textStreamUrl","IsExternalUrl","DeliveryUrl","language","Language","isDefault","DefaultSubtitleStreamIndex","format","Codec","playbackInfoResult","getOptimalMediaSource","versions","promises","v","optimalVersion","RequiresOpening","getLiveStream","postData","DeviceProfile","OpenToken","ajax","data","dataType","openLiveStreamResult","MediaSource","forceLocalPlayers","serverItem","getAutomaticPlayers","forceLocalPlayer","getPlayers","canPlayItem","canPlayUrl","queue","mode","queueAll","profile","queueNext","onPlayerProgressInterval","startPlaybackProgressTimer","_progressInterval","setInterval","bind","clearInterval","playbackStartTimeTicks","DefaultAudioStreamIndex","IsFirstItem","IsFullscreen","onPlaybackStartedFromSelfManagingPlayer","onPlaybackStoppedFromSelfManagingPlayer","playerStopInfo","playbackStopInfo","NextMediaType","PositionTicks","positionMs","NextItem","nextItemPlayOptions","error","errorType","currentlyPreventsVideoStreamCopy","currentlyPreventsAudioStreamCopy","enablePlaybackRetryWithTranscoding","displayErrorCode","getNextItemInfo","reset","on","onPlaybackTimeUpdate","onPlaybackPause","onPlaybackUnpause","onPlaybackVolumeChange","onRepeatModeChange","onShuffleQueueModeChange","onPlaylistItemMove","onPlaylistItemRemove","onPlaylistItemAdd","initMediaPlayer","priority","currentState","getVolume","setVolume","initLegacyVolumeMethods","volume","val","bindToFullscreenChange","screenfull","isEnabled","document","addEventListener","getLiveStreamMediaInfo","isMinServerVersion","PlayQueueManager","getPlayerInfo","deviceName","setActivePlayer","trySetActivePlayer","tryPair","targets","subTargets","j","isPlaying","currentSrc","isPlayingMediaType","isPlayingLocally","mediaTypes","isPlayingVideo","isPlayingAudio","canPlay","itemType","LocationType","EndDate","StartDate","datetime","parseISO8601Date","toggleAspectRatio","current","getAspectRatio","supported","getSupportedAspectRatios","setAspectRatio","increasePlaybackRate","getPlaybackRate","getSupportedPlaybackRates","min","setPlaybackRate","decreasePlaybackRate","max","setBrightness","getBrightness","volumeUp","volumeDown","changeAudioStream","mediaStreams","currentStreamIndex","getAudioStreamIndex","indexInList","nextIndex","setAudioStreamIndex","changeSubtitleStream","getSubtitleStreamIndex","setSubtitleStreamIndex","canSetAudioStreamIndex","isAudioStreamSupported","mediaStream","codec","setMaxStreamingBitrate","isFullscreen","webkitIsFullScreen","toggleFullscreen","toggle","webkitCancelFullscreen","elem","querySelector","webkitEnterFullscreen","togglePictureInPicture","toggleAirPlay","currentStream","getCurrentSubtitleStream","newStream","selectedTrackElementIndex","currentPlayMethod","supportSubtitleOffset","enableShowingSubtitleOffset","disableShowingSubtitleOffset","isShowingSubtitleOffsetEnabled","isSubtitleStreamExternal","stream","setSubtitleOffset","getPlayerSubtitleOffset","getSubtitleOffset","canHandleOffsetOnCurrentSubtitle","seek","seekRelative","offsetTicks","enableRemotePlayers","VolumeLevel","IsMuted","isMuted","IsPaused","paused","RepeatMode","getRepeatMode","ShuffleMode","getQueueShuffleMode","PlaybackStartTimeTicks","playbackStartTime","BufferedRanges","getBufferedRanges","PlayMethod","getCurrentPlaylistItemId","CanSeek","getNowPlayingItemForReporting","nowPlayingItem","playerDuration","getPlaybackMediaSources","setCurrentPlaylistItem","newItemIndex","playlist","newItemPlayOptions","removeFromPlaylist","playlistItemIds","removeResult","isCurrentIndex","movePlaylistItem","newIndex","moveResult","getCurrentPlaylistIndex","channelUp","channelDown","previousTrack","newItemInfo","arguments","undefined","plugin","onAppClose","_ref2","serverNotifications","setDefaultPlayerActive","_createClass","protoProps","staticProps","getCurrentPlayer","canQueue","canQueueMediaType","setMute","mute","toggleMute","toggleDisplayMirroring","enableDisplayMirroring","enabled","nextChapter","Chapters","StartPositionTicks","previousChapter","previousChapters","fastForward","skipForwardLength","rewind","skipBackLength","seekPercent","percent","seekMs","ms","playTrailers","LocalTrailerCount","getLocalTrailers","remoteTrailers","RemoteTrailers","getSubtitleUrl","playPause","unpause","pause","instantMix","getInstantMixFromItem","shuffleItem","audioTracks","list","setRepeatMode","setQueueShuffleMode","setShuffleMode","getShuffleMode","toggleQueueShuffleMode","toggleShuffleMode","clearQueue","clearCurrentItem","clearPlaylist","trySetActiveDeviceName","displayContent","removeActivePlayer","playerInfo","removeActiveTarget","sendCommand","cmd","Arguments","Volume","AspectRatio","PlaybackRate","Brightness","Bitrate"],"mappings":"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","file":"playbackmanager.js","sourcesContent":["import events from 'events';\nimport datetime from 'datetime';\nimport appSettings from 'appSettings';\nimport itemHelper from 'itemHelper';\nimport pluginManager from 'pluginManager';\nimport PlayQueueManager from 'playQueueManager';\nimport * as userSettings from 'userSettings';\nimport globalize from 'globalize';\nimport connectionManager from 'connectionManager';\nimport loading from 'loading';\nimport appHost from 'apphost';\nimport screenfull from 'screenfull';\n\nfunction enableLocalPlaylistManagement(player) {\n    if (player.getPlaylist) {\n        return false;\n    }\n\n    if (player.isLocalPlayer) {\n        return true;\n    }\n\n    return false;\n}\n\nfunction bindToFullscreenChange(player) {\n    if (screenfull.isEnabled) {\n        screenfull.on('change', function () {\n            events.trigger(player, 'fullscreenchange');\n        });\n    } else {\n        // iOS Safari\n        document.addEventListener('webkitfullscreenchange', function () {\n            events.trigger(player, 'fullscreenchange');\n        }, false);\n    }\n}\n\nfunction triggerPlayerChange(playbackManagerInstance, newPlayer, newTarget, previousPlayer, previousTargetInfo) {\n    if (!newPlayer && !previousPlayer) {\n        return;\n    }\n\n    if (newTarget && previousTargetInfo) {\n        if (newTarget.id === previousTargetInfo.id) {\n            return;\n        }\n    }\n\n    events.trigger(playbackManagerInstance, 'playerchange', [newPlayer, newTarget, previousPlayer]);\n}\n\nfunction reportPlayback(playbackManagerInstance, state, player, reportPlaylist, serverId, method, progressEventName) {\n    if (!serverId) {\n        // Not a server item\n        // We can expand on this later and possibly report them\n        events.trigger(playbackManagerInstance, 'reportplayback', [false]);\n        return;\n    }\n\n    const info = Object.assign({}, state.PlayState);\n    info.ItemId = state.NowPlayingItem.Id;\n\n    if (progressEventName) {\n        info.EventName = progressEventName;\n    }\n\n    if (reportPlaylist) {\n        addPlaylistToPlaybackReport(playbackManagerInstance, info, player, serverId);\n    }\n\n    const apiClient = connectionManager.getApiClient(serverId);\n    const reportPlaybackPromise = apiClient[method](info);\n    // Notify that report has been sent\n    reportPlaybackPromise.then(() => {\n        events.trigger(playbackManagerInstance, 'reportplayback', [true]);\n    });\n}\n\nfunction getPlaylistSync(playbackManagerInstance, player) {\n    player = player || playbackManagerInstance._currentPlayer;\n    if (player && !enableLocalPlaylistManagement(player)) {\n        return player.getPlaylistSync();\n    }\n\n    return playbackManagerInstance._playQueueManager.getPlaylist();\n}\n\nfunction addPlaylistToPlaybackReport(playbackManagerInstance, info, player, serverId) {\n    info.NowPlayingQueue = getPlaylistSync(playbackManagerInstance, player).map(function (i) {\n        const itemInfo = {\n            Id: i.Id,\n            PlaylistItemId: i.PlaylistItemId\n        };\n\n        if (i.ServerId !== serverId) {\n            itemInfo.ServerId = i.ServerId;\n        }\n\n        return itemInfo;\n    });\n}\n\nfunction normalizeName(t) {\n    return t.toLowerCase().replace(' ', '');\n}\n\nfunction getItemsForPlayback(serverId, query) {\n    const apiClient = connectionManager.getApiClient(serverId);\n\n    if (query.Ids && query.Ids.split(',').length === 1) {\n        const itemId = query.Ids.split(',');\n\n        return apiClient.getItem(apiClient.getCurrentUserId(), itemId).then(function (item) {\n            return {\n                Items: [item],\n                TotalRecordCount: 1\n            };\n        });\n    } else {\n        query.Limit = query.Limit || 300;\n        query.Fields = 'Chapters';\n        query.ExcludeLocationTypes = 'Virtual';\n        query.EnableTotalRecordCount = false;\n        query.CollapseBoxSetItems = false;\n\n        return apiClient.getItems(apiClient.getCurrentUserId(), query);\n    }\n}\n\nfunction createStreamInfoFromUrlItem(item) {\n    // Check item.Path for games\n    return {\n        url: item.Url || item.Path,\n        playMethod: 'DirectPlay',\n        item: item,\n        textTracks: [],\n        mediaType: item.MediaType\n    };\n}\n\nfunction mergePlaybackQueries(obj1, obj2) {\n    const query = Object.assign(obj1, obj2);\n\n    const filters = query.Filters ? query.Filters.split(',') : [];\n    if (filters.indexOf('IsNotFolder') === -1) {\n        filters.push('IsNotFolder');\n    }\n    query.Filters = filters.join(',');\n    return query;\n}\n\nfunction backdropImageUrl(apiClient, item, options) {\n    options = options || {};\n    options.type = options.type || 'Backdrop';\n\n    // If not resizing, get the original image\n    if (!options.maxWidth && !options.width && !options.maxHeight && !options.height) {\n        options.quality = 100;\n    }\n\n    if (item.BackdropImageTags && item.BackdropImageTags.length) {\n        options.tag = item.BackdropImageTags[0];\n        return apiClient.getScaledImageUrl(item.Id, options);\n    }\n\n    if (item.ParentBackdropImageTags && item.ParentBackdropImageTags.length) {\n        options.tag = item.ParentBackdropImageTags[0];\n        return apiClient.getScaledImageUrl(item.ParentBackdropItemId, options);\n    }\n\n    return null;\n}\n\nfunction getMimeType(type, container) {\n    container = (container || '').toLowerCase();\n\n    if (type === 'audio') {\n        if (container === 'opus') {\n            return 'audio/ogg';\n        }\n        if (container === 'webma') {\n            return 'audio/webm';\n        }\n        if (container === 'm4a') {\n            return 'audio/mp4';\n        }\n    } else if (type === 'video') {\n        if (container === 'mkv') {\n            return 'video/x-matroska';\n        }\n        if (container === 'm4v') {\n            return 'video/mp4';\n        }\n        if (container === 'mov') {\n            return 'video/quicktime';\n        }\n        if (container === 'mpg') {\n            return 'video/mpeg';\n        }\n        if (container === 'flv') {\n            return 'video/x-flv';\n        }\n    }\n\n    return type + '/' + container;\n}\n\nfunction getParam(name, url) {\n    name = name.replace(/[\\[]/, '\\\\\\[').replace(/[\\]]/, '\\\\\\]');\n    const regexS = '[\\\\?&]' + name + '=([^&#]*)';\n    const regex = new RegExp(regexS, 'i');\n\n    const results = regex.exec(url);\n    if (results == null) {\n        return '';\n    } else {\n        return decodeURIComponent(results[1].replace(/\\+/g, ' '));\n    }\n}\n\nfunction isAutomaticPlayer(player) {\n    if (player.isLocalPlayer) {\n        return true;\n    }\n\n    return false;\n}\n\nfunction getAutomaticPlayers(instance, forceLocalPlayer) {\n    if (!forceLocalPlayer) {\n        const player = instance._currentPlayer;\n        if (player && !isAutomaticPlayer(player)) {\n            return [player];\n        }\n    }\n\n    return instance.getPlayers().filter(isAutomaticPlayer);\n}\n\nfunction isServerItem(item) {\n    if (!item.Id) {\n        return false;\n    }\n    return true;\n}\n\nfunction enableIntros(item) {\n    if (item.MediaType !== 'Video') {\n        return false;\n    }\n    if (item.Type === 'TvChannel') {\n        return false;\n    }\n    // disable for in-progress recordings\n    if (item.Status === 'InProgress') {\n        return false;\n    }\n\n    return isServerItem(item);\n}\n\nfunction getIntros(firstItem, apiClient, options) {\n    if (options.startPositionTicks || options.startIndex || options.fullscreen === false || !enableIntros(firstItem) || !userSettings.enableCinemaMode()) {\n        return Promise.resolve({\n            Items: []\n        });\n    }\n\n    return apiClient.getIntros(firstItem.Id).then(function (result) {\n        return result;\n    }, function (err) {\n        return Promise.resolve({\n            Items: []\n        });\n    });\n}\n\nfunction getAudioMaxValues(deviceProfile) {\n    // TODO - this could vary per codec and should be done on the server using the entire profile\n    let maxAudioSampleRate = null;\n    let maxAudioBitDepth = null;\n    let maxAudioBitrate = null;\n\n    deviceProfile.CodecProfiles.map(function (codecProfile) {\n        if (codecProfile.Type === 'Audio') {\n            (codecProfile.Conditions || []).map(function (condition) {\n                if (condition.Condition === 'LessThanEqual' && condition.Property === 'AudioBitDepth') {\n                    return maxAudioBitDepth = condition.Value;\n                } else if (condition.Condition === 'LessThanEqual' && condition.Property === 'AudioSampleRate') {\n                    return maxAudioSampleRate = condition.Value;\n                } else if (condition.Condition === 'LessThanEqual' && condition.Property === 'AudioBitrate') {\n                    return maxAudioBitrate = condition.Value;\n                }\n            });\n        }\n    });\n\n    return {\n        maxAudioSampleRate: maxAudioSampleRate,\n        maxAudioBitDepth: maxAudioBitDepth,\n        maxAudioBitrate: maxAudioBitrate\n    };\n}\n\nlet startingPlaySession = new Date().getTime();\nfunction getAudioStreamUrl(item, transcodingProfile, directPlayContainers, maxBitrate, apiClient, maxAudioSampleRate, maxAudioBitDepth, maxAudioBitrate, startPosition) {\n    const url = 'Audio/' + item.Id + '/universal';\n\n    startingPlaySession++;\n    return apiClient.getUrl(url, {\n        UserId: apiClient.getCurrentUserId(),\n        DeviceId: apiClient.deviceId(),\n        MaxStreamingBitrate: maxAudioBitrate || maxBitrate,\n        Container: directPlayContainers,\n        TranscodingContainer: transcodingProfile.Container || null,\n        TranscodingProtocol: transcodingProfile.Protocol || null,\n        AudioCodec: transcodingProfile.AudioCodec,\n        MaxAudioSampleRate: maxAudioSampleRate,\n        MaxAudioBitDepth: maxAudioBitDepth,\n        api_key: apiClient.accessToken(),\n        PlaySessionId: startingPlaySession,\n        StartTimeTicks: startPosition || 0,\n        EnableRedirection: true,\n        EnableRemoteMedia: appHost.supports('remoteaudio')\n    });\n}\n\nfunction getAudioStreamUrlFromDeviceProfile(item, deviceProfile, maxBitrate, apiClient, startPosition) {\n    const transcodingProfile = deviceProfile.TranscodingProfiles.filter(function (p) {\n        return p.Type === 'Audio' && p.Context === 'Streaming';\n    })[0];\n\n    let directPlayContainers = '';\n\n    deviceProfile.DirectPlayProfiles.map(function (p) {\n        if (p.Type === 'Audio') {\n            if (directPlayContainers) {\n                directPlayContainers += ',' + p.Container;\n            } else {\n                directPlayContainers = p.Container;\n            }\n\n            if (p.AudioCodec) {\n                directPlayContainers += '|' + p.AudioCodec;\n            }\n        }\n    });\n\n    const maxValues = getAudioMaxValues(deviceProfile);\n\n    return getAudioStreamUrl(item, transcodingProfile, directPlayContainers, maxBitrate, apiClient, maxValues.maxAudioSampleRate, maxValues.maxAudioBitDepth, maxValues.maxAudioBitrate, startPosition);\n}\n\nfunction getStreamUrls(items, deviceProfile, maxBitrate, apiClient, startPosition) {\n    const audioTranscodingProfile = deviceProfile.TranscodingProfiles.filter(function (p) {\n        return p.Type === 'Audio' && p.Context === 'Streaming';\n    })[0];\n\n    let audioDirectPlayContainers = '';\n\n    deviceProfile.DirectPlayProfiles.map(function (p) {\n        if (p.Type === 'Audio') {\n            if (audioDirectPlayContainers) {\n                audioDirectPlayContainers += ',' + p.Container;\n            } else {\n                audioDirectPlayContainers = p.Container;\n            }\n\n            if (p.AudioCodec) {\n                audioDirectPlayContainers += '|' + p.AudioCodec;\n            }\n        }\n    });\n\n    const maxValues = getAudioMaxValues(deviceProfile);\n\n    const streamUrls = [];\n\n    for (let i = 0, length = items.length; i < length; i++) {\n        const item = items[i];\n        let streamUrl;\n\n        if (item.MediaType === 'Audio' && !itemHelper.isLocalItem(item)) {\n            streamUrl = getAudioStreamUrl(item, audioTranscodingProfile, audioDirectPlayContainers, maxBitrate, apiClient, maxValues.maxAudioSampleRate, maxValues.maxAudioBitDepth, maxValues.maxAudioBitrate, startPosition);\n        }\n\n        streamUrls.push(streamUrl || '');\n\n        if (i === 0) {\n            startPosition = 0;\n        }\n    }\n\n    return Promise.resolve(streamUrls);\n}\n\nfunction setStreamUrls(items, deviceProfile, maxBitrate, apiClient, startPosition) {\n    return getStreamUrls(items, deviceProfile, maxBitrate, apiClient, startPosition).then(function (streamUrls) {\n        for (let i = 0, length = items.length; i < length; i++) {\n            const item = items[i];\n            const streamUrl = streamUrls[i];\n\n            if (streamUrl) {\n                item.PresetMediaSource = {\n                    StreamUrl: streamUrl,\n                    Id: item.Id,\n                    MediaStreams: [],\n                    RunTimeTicks: item.RunTimeTicks\n                };\n            }\n        }\n    });\n}\n\nfunction getPlaybackInfo(player,\n    apiClient,\n    item,\n    deviceProfile,\n    maxBitrate,\n    startPosition,\n    isPlayback,\n    mediaSourceId,\n    audioStreamIndex,\n    subtitleStreamIndex,\n    liveStreamId,\n    enableDirectPlay,\n    enableDirectStream,\n    allowVideoStreamCopy,\n    allowAudioStreamCopy) {\n    if (!itemHelper.isLocalItem(item) && item.MediaType === 'Audio') {\n        return Promise.resolve({\n            MediaSources: [\n                {\n                    StreamUrl: getAudioStreamUrlFromDeviceProfile(item, deviceProfile, maxBitrate, apiClient, startPosition),\n                    Id: item.Id,\n                    MediaStreams: [],\n                    RunTimeTicks: item.RunTimeTicks\n                }]\n        });\n    }\n\n    if (item.PresetMediaSource) {\n        return Promise.resolve({\n            MediaSources: [item.PresetMediaSource]\n        });\n    }\n\n    const itemId = item.Id;\n\n    const query = {\n        UserId: apiClient.getCurrentUserId(),\n        StartTimeTicks: startPosition || 0\n    };\n\n    if (isPlayback) {\n        query.IsPlayback = true;\n        query.AutoOpenLiveStream = true;\n    } else {\n        query.IsPlayback = false;\n        query.AutoOpenLiveStream = false;\n    }\n\n    if (audioStreamIndex != null) {\n        query.AudioStreamIndex = audioStreamIndex;\n    }\n    if (subtitleStreamIndex != null) {\n        query.SubtitleStreamIndex = subtitleStreamIndex;\n    }\n    if (enableDirectPlay != null) {\n        query.EnableDirectPlay = enableDirectPlay;\n    }\n\n    if (enableDirectStream != null) {\n        query.EnableDirectStream = enableDirectStream;\n    }\n    if (allowVideoStreamCopy != null) {\n        query.AllowVideoStreamCopy = allowVideoStreamCopy;\n    }\n    if (allowAudioStreamCopy != null) {\n        query.AllowAudioStreamCopy = allowAudioStreamCopy;\n    }\n    if (mediaSourceId) {\n        query.MediaSourceId = mediaSourceId;\n    }\n    if (liveStreamId) {\n        query.LiveStreamId = liveStreamId;\n    }\n    if (maxBitrate) {\n        query.MaxStreamingBitrate = maxBitrate;\n    }\n    if (player.enableMediaProbe && !player.enableMediaProbe(item)) {\n        query.EnableMediaProbe = false;\n    }\n\n    // lastly, enforce player overrides for special situations\n    if (query.EnableDirectStream !== false) {\n        if (player.supportsPlayMethod && !player.supportsPlayMethod('DirectStream', item)) {\n            query.EnableDirectStream = false;\n        }\n    }\n\n    if (player.getDirectPlayProtocols) {\n        query.DirectPlayProtocols = player.getDirectPlayProtocols();\n    }\n\n    return apiClient.getPlaybackInfo(itemId, query, deviceProfile);\n}\n\nfunction getOptimalMediaSource(apiClient, item, versions) {\n    const promises = versions.map(function (v) {\n        return supportsDirectPlay(apiClient, item, v);\n    });\n\n    if (!promises.length) {\n        return Promise.reject();\n    }\n\n    return Promise.all(promises).then(function (results) {\n        for (let i = 0, length = versions.length; i < length; i++) {\n            versions[i].enableDirectPlay = results[i] || false;\n        }\n        let optimalVersion = versions.filter(function (v) {\n            return v.enableDirectPlay;\n        })[0];\n\n        if (!optimalVersion) {\n            optimalVersion = versions.filter(function (v) {\n                return v.SupportsDirectStream;\n            })[0];\n        }\n\n        optimalVersion = optimalVersion || versions.filter(function (s) {\n            return s.SupportsTranscoding;\n        })[0];\n\n        return optimalVersion || versions[0];\n    });\n}\n\nfunction getLiveStream(player, apiClient, item, playSessionId, deviceProfile, maxBitrate, startPosition, mediaSource, audioStreamIndex, subtitleStreamIndex) {\n    const postData = {\n        DeviceProfile: deviceProfile,\n        OpenToken: mediaSource.OpenToken\n    };\n\n    const query = {\n        UserId: apiClient.getCurrentUserId(),\n        StartTimeTicks: startPosition || 0,\n        ItemId: item.Id,\n        PlaySessionId: playSessionId\n    };\n\n    if (maxBitrate) {\n        query.MaxStreamingBitrate = maxBitrate;\n    }\n    if (audioStreamIndex != null) {\n        query.AudioStreamIndex = audioStreamIndex;\n    }\n    if (subtitleStreamIndex != null) {\n        query.SubtitleStreamIndex = subtitleStreamIndex;\n    }\n\n    // lastly, enforce player overrides for special situations\n    if (query.EnableDirectStream !== false) {\n        if (player.supportsPlayMethod && !player.supportsPlayMethod('DirectStream', item)) {\n            query.EnableDirectStream = false;\n        }\n    }\n\n    return apiClient.ajax({\n        url: apiClient.getUrl('LiveStreams/Open', query),\n        type: 'POST',\n        data: JSON.stringify(postData),\n        contentType: 'application/json',\n        dataType: 'json'\n\n    });\n}\n\nfunction isHostReachable(mediaSource, apiClient) {\n    if (mediaSource.IsRemote) {\n        return Promise.resolve(true);\n    }\n\n    return apiClient.getEndpointInfo().then(function (endpointInfo) {\n        if (endpointInfo.IsInNetwork) {\n            if (!endpointInfo.IsLocal) {\n                const path = (mediaSource.Path || '').toLowerCase();\n                if (path.indexOf('localhost') !== -1 || path.indexOf('127.0.0.1') !== -1) {\n                    // This will only work if the app is on the same machine as the server\n                    return Promise.resolve(false);\n                }\n            }\n\n            return Promise.resolve(true);\n        }\n\n        // media source is in network, but connection is out of network\n        return Promise.resolve(false);\n    });\n}\n\nfunction supportsDirectPlay(apiClient, item, mediaSource) {\n    // folder rip hacks due to not yet being supported by the stream building engine\n    const isFolderRip = mediaSource.VideoType === 'BluRay' || mediaSource.VideoType === 'Dvd' || mediaSource.VideoType === 'HdDvd';\n\n    if (mediaSource.SupportsDirectPlay || isFolderRip) {\n        if (mediaSource.IsRemote && !appHost.supports('remotevideo')) {\n            return Promise.resolve(false);\n        }\n\n        if (mediaSource.Protocol === 'Http' && !mediaSource.RequiredHttpHeaders.length) {\n            // If this is the only way it can be played, then allow it\n            if (!mediaSource.SupportsDirectStream && !mediaSource.SupportsTranscoding) {\n                return Promise.resolve(true);\n            } else {\n                return isHostReachable(mediaSource, apiClient);\n            }\n        } else if (mediaSource.Protocol === 'File') {\n            return new Promise(function (resolve, reject) {\n                // Determine if the file can be accessed directly\n                import('filesystem').then((filesystem) => {\n                    const method = isFolderRip ?\n                        'directoryExists' :\n                        'fileExists';\n\n                    filesystem[method](mediaSource.Path).then(function () {\n                        resolve(true);\n                    }, function () {\n                        resolve(false);\n                    });\n                });\n            });\n        }\n    }\n\n    return Promise.resolve(false);\n}\n\nfunction validatePlaybackInfoResult(instance, result) {\n    if (result.ErrorCode) {\n        showPlaybackInfoErrorMessage(instance, result.ErrorCode);\n        return false;\n    }\n\n    return true;\n}\n\nfunction showPlaybackInfoErrorMessage(instance, errorCode, playNextTrack) {\n    import('alert').then(({ default: alert }) => {\n        alert({\n            text: globalize.translate('PlaybackError' + errorCode),\n            title: globalize.translate('HeaderPlaybackError')\n        }).then(function () {\n            if (playNextTrack) {\n                instance.nextTrack();\n            }\n        });\n    });\n}\n\nfunction normalizePlayOptions(playOptions) {\n    playOptions.fullscreen = playOptions.fullscreen !== false;\n}\n\nfunction truncatePlayOptions(playOptions) {\n    return {\n        fullscreen: playOptions.fullscreen,\n        mediaSourceId: playOptions.mediaSourceId,\n        audioStreamIndex: playOptions.audioStreamIndex,\n        subtitleStreamIndex: playOptions.subtitleStreamIndex,\n        startPositionTicks: playOptions.startPositionTicks\n    };\n}\n\nfunction getNowPlayingItemForReporting(player, item, mediaSource) {\n    const nowPlayingItem = Object.assign({}, item);\n\n    if (mediaSource) {\n        nowPlayingItem.RunTimeTicks = mediaSource.RunTimeTicks;\n        nowPlayingItem.MediaStreams = mediaSource.MediaStreams;\n\n        // not needed\n        nowPlayingItem.MediaSources = null;\n    }\n\n    nowPlayingItem.RunTimeTicks = nowPlayingItem.RunTimeTicks || player.duration() * 10000;\n\n    return nowPlayingItem;\n}\n\nfunction displayPlayerIndividually(player) {\n    return !player.isLocalPlayer;\n}\n\nfunction createTarget(instance, player) {\n    return {\n        name: player.name,\n        id: player.id,\n        playerName: player.name,\n        playableMediaTypes: ['Audio', 'Video', 'Photo', 'Book'].map(player.canPlayMediaType),\n        isLocalPlayer: player.isLocalPlayer,\n        supportedCommands: instance.getSupportedCommands(player)\n    };\n}\n\nfunction getPlayerTargets(player) {\n    if (player.getTargets) {\n        return player.getTargets();\n    }\n\n    return Promise.resolve([createTarget(player)]);\n}\n\nfunction sortPlayerTargets(a, b) {\n    let aVal = a.isLocalPlayer ? 0 : 1;\n    let bVal = b.isLocalPlayer ? 0 : 1;\n\n    aVal = aVal.toString() + a.name;\n    bVal = bVal.toString() + b.name;\n\n    return aVal.localeCompare(bVal);\n}\n\nclass PlaybackManager {\n    constructor() {\n        const self = this;\n\n        const players = [];\n        let currentTargetInfo;\n        let currentPairingId = null;\n\n        this._playNextAfterEnded = true;\n        const playerStates = {};\n\n        this._playQueueManager = new PlayQueueManager();\n\n        self.currentItem = function (player) {\n            if (!player) {\n                throw new Error('player cannot be null');\n            }\n\n            if (player.currentItem) {\n                return player.currentItem();\n            }\n\n            const data = getPlayerData(player);\n            return data.streamInfo ? data.streamInfo.item : null;\n        };\n\n        self.currentMediaSource = function (player) {\n            if (!player) {\n                throw new Error('player cannot be null');\n            }\n\n            if (player.currentMediaSource) {\n                return player.currentMediaSource();\n            }\n\n            const data = getPlayerData(player);\n            return data.streamInfo ? data.streamInfo.mediaSource : null;\n        };\n\n        self.playMethod = function (player) {\n            if (!player) {\n                throw new Error('player cannot be null');\n            }\n\n            if (player.playMethod) {\n                return player.playMethod();\n            }\n\n            const data = getPlayerData(player);\n            return data.streamInfo ? data.streamInfo.playMethod : null;\n        };\n\n        self.playSessionId = function (player) {\n            if (!player) {\n                throw new Error('player cannot be null');\n            }\n\n            if (player.playSessionId) {\n                return player.playSessionId();\n            }\n\n            const data = getPlayerData(player);\n            return data.streamInfo ? data.streamInfo.playSessionId : null;\n        };\n\n        self.getPlayerInfo = function () {\n            const player = self._currentPlayer;\n\n            if (!player) {\n                return null;\n            }\n\n            const target = currentTargetInfo || {};\n\n            return {\n                name: player.name,\n                isLocalPlayer: player.isLocalPlayer,\n                id: target.id,\n                deviceName: target.deviceName,\n                playableMediaTypes: target.playableMediaTypes,\n                supportedCommands: target.supportedCommands\n            };\n        };\n\n        self.setActivePlayer = function (player, targetInfo) {\n            if (player === 'localplayer' || player.name === 'localplayer') {\n                if (self._currentPlayer && self._currentPlayer.isLocalPlayer) {\n                    return;\n                }\n                setCurrentPlayerInternal(null, null);\n                return;\n            }\n\n            if (typeof (player) === 'string') {\n                player = players.filter(function (p) {\n                    return p.name === player;\n                })[0];\n            }\n\n            if (!player) {\n                throw new Error('null player');\n            }\n\n            setCurrentPlayerInternal(player, targetInfo);\n        };\n\n        self.trySetActivePlayer = function (player, targetInfo) {\n            if (player === 'localplayer' || player.name === 'localplayer') {\n                if (self._currentPlayer && self._currentPlayer.isLocalPlayer) {\n                    return;\n                }\n                return;\n            }\n\n            if (typeof (player) === 'string') {\n                player = players.filter(function (p) {\n                    return p.name === player;\n                })[0];\n            }\n\n            if (!player) {\n                throw new Error('null player');\n            }\n\n            if (currentPairingId === targetInfo.id) {\n                return;\n            }\n\n            currentPairingId = targetInfo.id;\n\n            const promise = player.tryPair ?\n                player.tryPair(targetInfo) :\n                Promise.resolve();\n\n            events.trigger(self, 'pairing');\n\n            promise.then(function () {\n                events.trigger(self, 'paired');\n                setCurrentPlayerInternal(player, targetInfo);\n            }, function () {\n                events.trigger(self, 'pairerror');\n                if (currentPairingId === targetInfo.id) {\n                    currentPairingId = null;\n                }\n            });\n        };\n\n        self.getTargets = function () {\n            const promises = players.filter(displayPlayerIndividually).map(getPlayerTargets);\n\n            return Promise.all(promises).then(function (responses) {\n                return connectionManager.currentApiClient().getCurrentUser().then(function (user) {\n                    const targets = [];\n\n                    targets.push({\n                        name: globalize.translate('HeaderMyDevice'),\n                        id: 'localplayer',\n                        playerName: 'localplayer',\n                        playableMediaTypes: ['Audio', 'Video', 'Photo', 'Book'],\n                        isLocalPlayer: true,\n                        supportedCommands: self.getSupportedCommands({\n                            isLocalPlayer: true\n                        }),\n                        user: user\n                    });\n\n                    for (let i = 0; i < responses.length; i++) {\n                        const subTargets = responses[i];\n\n                        for (let j = 0; j < subTargets.length; j++) {\n                            targets.push(subTargets[j]);\n                        }\n                    }\n\n                    return targets.sort(sortPlayerTargets);\n                });\n            });\n        };\n\n        function getCurrentSubtitleStream(player) {\n            if (!player) {\n                throw new Error('player cannot be null');\n            }\n\n            const index = getPlayerData(player).subtitleStreamIndex;\n\n            if (index == null || index === -1) {\n                return null;\n            }\n\n            return getSubtitleStream(player, index);\n        }\n\n        function getSubtitleStream(player, index) {\n            return self.subtitleTracks(player).filter(function (s) {\n                return s.Type === 'Subtitle' && s.Index === index;\n            })[0];\n        }\n\n        self.getPlaylist = function (player) {\n            player = player || self._currentPlayer;\n            if (player && !enableLocalPlaylistManagement(player)) {\n                if (player.getPlaylistSync) {\n                    return Promise.resolve(player.getPlaylistSync());\n                }\n\n                return player.getPlaylist();\n            }\n\n            return Promise.resolve(self._playQueueManager.getPlaylist());\n        };\n\n        function removeCurrentPlayer(player) {\n            const previousPlayer = self._currentPlayer;\n\n            if (!previousPlayer || player.id === previousPlayer.id) {\n                setCurrentPlayerInternal(null);\n            }\n        }\n\n        function setCurrentPlayerInternal(player, targetInfo) {\n            const previousPlayer = self._currentPlayer;\n            const previousTargetInfo = currentTargetInfo;\n\n            if (player && !targetInfo && player.isLocalPlayer) {\n                targetInfo = createTarget(self, player);\n            }\n\n            if (player && !targetInfo) {\n                throw new Error('targetInfo cannot be null');\n            }\n\n            currentPairingId = null;\n            self._currentPlayer = player;\n            currentTargetInfo = targetInfo;\n\n            if (targetInfo) {\n                console.debug('Active player: ' + JSON.stringify(targetInfo));\n            }\n\n            if (previousPlayer) {\n                self.endPlayerUpdates(previousPlayer);\n            }\n\n            if (player) {\n                self.beginPlayerUpdates(player);\n            }\n\n            triggerPlayerChange(self, player, targetInfo, previousPlayer, previousTargetInfo);\n        }\n\n        self.isPlaying = function (player) {\n            player = player || self._currentPlayer;\n\n            if (player) {\n                if (player.isPlaying) {\n                    return player.isPlaying();\n                }\n            }\n\n            return player != null && player.currentSrc() != null;\n        };\n\n        self.isPlayingMediaType = function (mediaType, player) {\n            player = player || self._currentPlayer;\n\n            if (player) {\n                if (player.isPlaying) {\n                    return player.isPlaying(mediaType);\n                }\n            }\n\n            if (self.isPlaying(player)) {\n                const playerData = getPlayerData(player);\n\n                return playerData.streamInfo.mediaType === mediaType;\n            }\n\n            return false;\n        };\n\n        self.isPlayingLocally = function (mediaTypes, player) {\n            player = player || self._currentPlayer;\n\n            if (!player || !player.isLocalPlayer) {\n                return false;\n            }\n\n            return mediaTypes.filter(function (mediaType) {\n                return self.isPlayingMediaType(mediaType, player);\n            }).length > 0;\n        };\n\n        self.isPlayingVideo = function (player) {\n            return self.isPlayingMediaType('Video', player);\n        };\n\n        self.isPlayingAudio = function (player) {\n            return self.isPlayingMediaType('Audio', player);\n        };\n\n        self.getPlayers = function () {\n            return players;\n        };\n\n        function getDefaultPlayOptions() {\n            return {\n                fullscreen: true\n            };\n        }\n\n        self.canPlay = function (item) {\n            const itemType = item.Type;\n\n            if (itemType === 'PhotoAlbum' || itemType === 'MusicGenre' || itemType === 'Season' || itemType === 'Series' || itemType === 'BoxSet' || itemType === 'MusicAlbum' || itemType === 'MusicArtist' || itemType === 'Playlist') {\n                return true;\n            }\n\n            if (item.LocationType === 'Virtual') {\n                if (itemType !== 'Program') {\n                    return false;\n                }\n            }\n\n            if (itemType === 'Program') {\n                if (!item.EndDate || !item.StartDate) {\n                    return false;\n                }\n\n                if (new Date().getTime() > datetime.parseISO8601Date(item.EndDate).getTime() || new Date().getTime() < datetime.parseISO8601Date(item.StartDate).getTime()) {\n                    return false;\n                }\n            }\n\n            //var mediaType = item.MediaType;\n            return getPlayer(item, getDefaultPlayOptions()) != null;\n        };\n\n        self.toggleAspectRatio = function (player) {\n            player = player || self._currentPlayer;\n\n            if (player) {\n                const current = self.getAspectRatio(player);\n\n                const supported = self.getSupportedAspectRatios(player);\n\n                let index = -1;\n                for (let i = 0, length = supported.length; i < length; i++) {\n                    if (supported[i].id === current) {\n                        index = i;\n                        break;\n                    }\n                }\n\n                index++;\n                if (index >= supported.length) {\n                    index = 0;\n                }\n\n                self.setAspectRatio(supported[index].id, player);\n            }\n        };\n\n        self.setAspectRatio = function (val, player) {\n            player = player || self._currentPlayer;\n\n            if (player && player.setAspectRatio) {\n                player.setAspectRatio(val);\n            }\n        };\n\n        self.getSupportedAspectRatios = function (player) {\n            player = player || self._currentPlayer;\n\n            if (player && player.getSupportedAspectRatios) {\n                return player.getSupportedAspectRatios();\n            }\n\n            return [];\n        };\n\n        self.getAspectRatio = function (player) {\n            player = player || self._currentPlayer;\n\n            if (player && player.getAspectRatio) {\n                return player.getAspectRatio();\n            }\n        };\n\n        self.increasePlaybackRate = function (player) {\n            player = player || self._currentPlayer;\n            if (player) {\n                let current = self.getPlaybackRate(player);\n                let supported = self.getSupportedPlaybackRates(player);\n\n                let index = -1;\n                for (let i = 0, length = supported.length; i < length; i++) {\n                    if (supported[i].id === current) {\n                        index = i;\n                        break;\n                    }\n                }\n\n                index = Math.min(index + 1, supported.length - 1);\n                self.setPlaybackRate(supported[index].id, player);\n            }\n        };\n\n        self.decreasePlaybackRate = function (player) {\n            player = player || self._currentPlayer;\n            if (player) {\n                let current = self.getPlaybackRate(player);\n                let supported = self.getSupportedPlaybackRates(player);\n\n                let index = -1;\n                for (let i = 0, length = supported.length; i < length; i++) {\n                    if (supported[i].id === current) {\n                        index = i;\n                        break;\n                    }\n                }\n\n                index = Math.max(index - 1, 0);\n                self.setPlaybackRate(supported[index].id, player);\n            }\n        };\n\n        self.getSupportedPlaybackRates = function (player) {\n            player = player || self._currentPlayer;\n            if (player && player.getSupportedPlaybackRates) {\n                return player.getSupportedPlaybackRates();\n            }\n            return [];\n        };\n\n        let brightnessOsdLoaded;\n        self.setBrightness = function (val, player) {\n            player = player || self._currentPlayer;\n\n            if (player) {\n                if (!brightnessOsdLoaded) {\n                    brightnessOsdLoaded = true;\n                    // TODO: Have this trigger an event instead to get the osd out of here\n                    import('brightnessOsd').then();\n                }\n                player.setBrightness(val);\n            }\n        };\n\n        self.getBrightness = function (player) {\n            player = player || self._currentPlayer;\n\n            if (player) {\n                return player.getBrightness();\n            }\n        };\n\n        self.setVolume = function (val, player) {\n            player = player || self._currentPlayer;\n\n            if (player) {\n                player.setVolume(val);\n            }\n        };\n\n        self.getVolume = function (player) {\n            player = player || self._currentPlayer;\n\n            if (player) {\n                return player.getVolume();\n            }\n        };\n\n        self.volumeUp = function (player) {\n            player = player || self._currentPlayer;\n\n            if (player) {\n                player.volumeUp();\n            }\n        };\n\n        self.volumeDown = function (player) {\n            player = player || self._currentPlayer;\n\n            if (player) {\n                player.volumeDown();\n            }\n        };\n\n        self.changeAudioStream = function (player) {\n            player = player || self._currentPlayer;\n            if (player && !enableLocalPlaylistManagement(player)) {\n                return player.changeAudioStream();\n            }\n\n            if (!player) {\n                return;\n            }\n\n            const currentMediaSource = self.currentMediaSource(player);\n            const mediaStreams = [];\n            for (let i = 0, length = currentMediaSource.MediaStreams.length; i < length; i++) {\n                if (currentMediaSource.MediaStreams[i].Type === 'Audio') {\n                    mediaStreams.push(currentMediaSource.MediaStreams[i]);\n                }\n            }\n\n            // Nothing to change\n            if (mediaStreams.length <= 1) {\n                return;\n            }\n\n            const currentStreamIndex = self.getAudioStreamIndex(player);\n            let indexInList = -1;\n            for (let i = 0, length = mediaStreams.length; i < length; i++) {\n                if (mediaStreams[i].Index === currentStreamIndex) {\n                    indexInList = i;\n                    break;\n                }\n            }\n\n            let nextIndex = indexInList + 1;\n            if (nextIndex >= mediaStreams.length) {\n                nextIndex = 0;\n            }\n\n            nextIndex = nextIndex === -1 ? -1 : mediaStreams[nextIndex].Index;\n\n            self.setAudioStreamIndex(nextIndex, player);\n        };\n\n        self.changeSubtitleStream = function (player) {\n            player = player || self._currentPlayer;\n            if (player && !enableLocalPlaylistManagement(player)) {\n                return player.changeSubtitleStream();\n            }\n\n            if (!player) {\n                return;\n            }\n\n            const currentMediaSource = self.currentMediaSource(player);\n            const mediaStreams = [];\n            for (let i = 0, length = currentMediaSource.MediaStreams.length; i < length; i++) {\n                if (currentMediaSource.MediaStreams[i].Type === 'Subtitle') {\n                    mediaStreams.push(currentMediaSource.MediaStreams[i]);\n                }\n            }\n\n            // No known streams, nothing to change\n            if (!mediaStreams.length) {\n                return;\n            }\n\n            const currentStreamIndex = self.getSubtitleStreamIndex(player);\n            let indexInList = -1;\n            for (let i = 0, length = mediaStreams.length; i < length; i++) {\n                if (mediaStreams[i].Index === currentStreamIndex) {\n                    indexInList = i;\n                    break;\n                }\n            }\n\n            let nextIndex = indexInList + 1;\n            if (nextIndex >= mediaStreams.length) {\n                nextIndex = -1;\n            }\n\n            nextIndex = nextIndex === -1 ? -1 : mediaStreams[nextIndex].Index;\n\n            self.setSubtitleStreamIndex(nextIndex, player);\n        };\n\n        self.getAudioStreamIndex = function (player) {\n            player = player || self._currentPlayer;\n            if (player && !enableLocalPlaylistManagement(player)) {\n                return player.getAudioStreamIndex();\n            }\n\n            return getPlayerData(player).audioStreamIndex;\n        };\n\n        function isAudioStreamSupported(mediaSource, index, deviceProfile) {\n            let mediaStream;\n            const mediaStreams = mediaSource.MediaStreams;\n\n            for (let i = 0, length = mediaStreams.length; i < length; i++) {\n                if (mediaStreams[i].Type === 'Audio' && mediaStreams[i].Index === index) {\n                    mediaStream = mediaStreams[i];\n                    break;\n                }\n            }\n\n            if (!mediaStream) {\n                return false;\n            }\n\n            const codec = (mediaStream.Codec || '').toLowerCase();\n\n            if (!codec) {\n                return false;\n            }\n\n            const profiles = deviceProfile.DirectPlayProfiles || [];\n\n            return profiles.filter(function (p) {\n                if (p.Type === 'Video') {\n                    if (!p.AudioCodec) {\n                        return true;\n                    }\n\n                    // This is an exclusion filter\n                    if (p.AudioCodec.indexOf('-') === 0) {\n                        return p.AudioCodec.toLowerCase().indexOf(codec) === -1;\n                    }\n\n                    return p.AudioCodec.toLowerCase().indexOf(codec) !== -1;\n                }\n\n                return false;\n            }).length > 0;\n        }\n\n        self.setAudioStreamIndex = function (index, player) {\n            player = player || self._currentPlayer;\n            if (player && !enableLocalPlaylistManagement(player)) {\n                return player.setAudioStreamIndex(index);\n            }\n\n            if (self.playMethod(player) === 'Transcode' || !player.canSetAudioStreamIndex()) {\n                changeStream(player, getCurrentTicks(player), { AudioStreamIndex: index });\n                getPlayerData(player).audioStreamIndex = index;\n            } else {\n                // See if the player supports the track without transcoding\n                player.getDeviceProfile(self.currentItem(player)).then(function (profile) {\n                    if (isAudioStreamSupported(self.currentMediaSource(player), index, profile)) {\n                        player.setAudioStreamIndex(index);\n                        getPlayerData(player).audioStreamIndex = index;\n                    } else {\n                        changeStream(player, getCurrentTicks(player), { AudioStreamIndex: index });\n                        getPlayerData(player).audioStreamIndex = index;\n                    }\n                });\n            }\n        };\n\n        function getSavedMaxStreamingBitrate(apiClient, mediaType) {\n            if (!apiClient) {\n                // This should hopefully never happen\n                apiClient = connectionManager.currentApiClient();\n            }\n\n            const endpointInfo = apiClient.getSavedEndpointInfo() || {};\n\n            return appSettings.maxStreamingBitrate(endpointInfo.IsInNetwork, mediaType);\n        }\n\n        self.getMaxStreamingBitrate = function (player) {\n            player = player || self._currentPlayer;\n            if (player && player.getMaxStreamingBitrate) {\n                return player.getMaxStreamingBitrate();\n            }\n\n            const playerData = getPlayerData(player);\n\n            if (playerData.maxStreamingBitrate) {\n                return playerData.maxStreamingBitrate;\n            }\n\n            const mediaType = playerData.streamInfo ? playerData.streamInfo.mediaType : null;\n            const currentItem = self.currentItem(player);\n\n            const apiClient = currentItem ? connectionManager.getApiClient(currentItem.ServerId) : connectionManager.currentApiClient();\n            return getSavedMaxStreamingBitrate(apiClient, mediaType);\n        };\n\n        self.enableAutomaticBitrateDetection = function (player) {\n            player = player || self._currentPlayer;\n            if (player && player.enableAutomaticBitrateDetection) {\n                return player.enableAutomaticBitrateDetection();\n            }\n\n            const playerData = getPlayerData(player);\n            const mediaType = playerData.streamInfo ? playerData.streamInfo.mediaType : null;\n            const currentItem = self.currentItem(player);\n\n            const apiClient = currentItem ? connectionManager.getApiClient(currentItem.ServerId) : connectionManager.currentApiClient();\n            const endpointInfo = apiClient.getSavedEndpointInfo() || {};\n\n            return appSettings.enableAutomaticBitrateDetection(endpointInfo.IsInNetwork, mediaType);\n        };\n\n        self.setMaxStreamingBitrate = function (options, player) {\n            player = player || self._currentPlayer;\n            if (player && player.setMaxStreamingBitrate) {\n                return player.setMaxStreamingBitrate(options);\n            }\n\n            const apiClient = connectionManager.getApiClient(self.currentItem(player).ServerId);\n\n            apiClient.getEndpointInfo().then(function (endpointInfo) {\n                const playerData = getPlayerData(player);\n                const mediaType = playerData.streamInfo ? playerData.streamInfo.mediaType : null;\n\n                let promise;\n                if (options.enableAutomaticBitrateDetection) {\n                    appSettings.enableAutomaticBitrateDetection(endpointInfo.IsInNetwork, mediaType, true);\n                    promise = apiClient.detectBitrate(true);\n                } else {\n                    appSettings.enableAutomaticBitrateDetection(endpointInfo.IsInNetwork, mediaType, false);\n                    promise = Promise.resolve(options.maxBitrate);\n                }\n\n                promise.then(function (bitrate) {\n                    appSettings.maxStreamingBitrate(endpointInfo.IsInNetwork, mediaType, bitrate);\n\n                    changeStream(player, getCurrentTicks(player), {\n                        MaxStreamingBitrate: bitrate\n                    });\n                });\n            });\n        };\n\n        self.isFullscreen = function (player) {\n            player = player || self._currentPlayer;\n            if (!player.isLocalPlayer || player.isFullscreen) {\n                return player.isFullscreen();\n            }\n\n            if (!screenfull.isEnabled) {\n                // iOS Safari\n                return document.webkitIsFullScreen;\n            }\n\n            return screenfull.isFullscreen;\n        };\n\n        self.toggleFullscreen = function (player) {\n            player = player || self._currentPlayer;\n            if (!player.isLocalPlayer || player.toggleFullscreen) {\n                return player.toggleFullscreen();\n            }\n\n            if (screenfull.isEnabled) {\n                screenfull.toggle();\n            } else {\n                // iOS Safari\n                if (document.webkitIsFullScreen && document.webkitCancelFullscreen) {\n                    document.webkitCancelFullscreen();\n                } else {\n                    const elem = document.querySelector('video');\n                    if (elem && elem.webkitEnterFullscreen) {\n                        elem.webkitEnterFullscreen();\n                    }\n                }\n            }\n        };\n\n        self.togglePictureInPicture = function (player) {\n            player = player || self._currentPlayer;\n            return player.togglePictureInPicture();\n        };\n\n        self.toggleAirPlay = function (player) {\n            player = player || self._currentPlayer;\n            return player.toggleAirPlay();\n        };\n\n        self.getSubtitleStreamIndex = function (player) {\n            player = player || self._currentPlayer;\n\n            if (player && !enableLocalPlaylistManagement(player)) {\n                return player.getSubtitleStreamIndex();\n            }\n\n            if (!player) {\n                throw new Error('player cannot be null');\n            }\n\n            return getPlayerData(player).subtitleStreamIndex;\n        };\n\n        function getDeliveryMethod(subtitleStream) {\n            // This will be null for internal subs for local items\n            if (subtitleStream.DeliveryMethod) {\n                return subtitleStream.DeliveryMethod;\n            }\n\n            return subtitleStream.IsExternal ? 'External' : 'Embed';\n        }\n\n        self.setSubtitleStreamIndex = function (index, player) {\n            player = player || self._currentPlayer;\n            if (player && !enableLocalPlaylistManagement(player)) {\n                return player.setSubtitleStreamIndex(index);\n            }\n\n            const currentStream = getCurrentSubtitleStream(player);\n\n            const newStream = getSubtitleStream(player, index);\n\n            if (!currentStream && !newStream) {\n                return;\n            }\n\n            let selectedTrackElementIndex = -1;\n\n            const currentPlayMethod = self.playMethod(player);\n\n            if (currentStream && !newStream) {\n                if (getDeliveryMethod(currentStream) === 'Encode' || (getDeliveryMethod(currentStream) === 'Embed' && currentPlayMethod === 'Transcode')) {\n                    // Need to change the transcoded stream to remove subs\n                    changeStream(player, getCurrentTicks(player), { SubtitleStreamIndex: -1 });\n                }\n            } else if (!currentStream && newStream) {\n                if (getDeliveryMethod(newStream) === 'External') {\n                    selectedTrackElementIndex = index;\n                } else if (getDeliveryMethod(newStream) === 'Embed' && currentPlayMethod !== 'Transcode') {\n                    selectedTrackElementIndex = index;\n                } else {\n                    // Need to change the transcoded stream to add subs\n                    changeStream(player, getCurrentTicks(player), { SubtitleStreamIndex: index });\n                }\n            } else if (currentStream && newStream) {\n                // Switching tracks\n                // We can handle this clientside if the new track is external or the new track is embedded and we're not transcoding\n                if (getDeliveryMethod(newStream) === 'External' || (getDeliveryMethod(newStream) === 'Embed' && currentPlayMethod !== 'Transcode')) {\n                    selectedTrackElementIndex = index;\n\n                    // But in order to handle this client side, if the previous track is being added via transcoding, we'll have to remove it\n                    if (getDeliveryMethod(currentStream) !== 'External' && getDeliveryMethod(currentStream) !== 'Embed') {\n                        changeStream(player, getCurrentTicks(player), { SubtitleStreamIndex: -1 });\n                    }\n                } else {\n                    // Need to change the transcoded stream to add subs\n                    changeStream(player, getCurrentTicks(player), { SubtitleStreamIndex: index });\n                }\n            }\n\n            player.setSubtitleStreamIndex(selectedTrackElementIndex);\n\n            getPlayerData(player).subtitleStreamIndex = index;\n        };\n\n        self.supportSubtitleOffset = function (player) {\n            player = player || self._currentPlayer;\n            return player && 'setSubtitleOffset' in player;\n        };\n\n        self.enableShowingSubtitleOffset = function (player) {\n            player = player || self._currentPlayer;\n            player.enableShowingSubtitleOffset();\n        };\n\n        self.disableShowingSubtitleOffset = function (player) {\n            player = player || self._currentPlayer;\n            if (player.disableShowingSubtitleOffset) {\n                player.disableShowingSubtitleOffset();\n            }\n        };\n\n        self.isShowingSubtitleOffsetEnabled = function (player) {\n            player = player || self._currentPlayer;\n            return player.isShowingSubtitleOffsetEnabled();\n        };\n\n        self.isSubtitleStreamExternal = function (index, player) {\n            const stream = getSubtitleStream(player, index);\n            return stream ? getDeliveryMethod(stream) === 'External' : false;\n        };\n\n        self.setSubtitleOffset = function (value, player) {\n            player = player || self._currentPlayer;\n            if (player.setSubtitleOffset) {\n                player.setSubtitleOffset(value);\n            }\n        };\n\n        self.getPlayerSubtitleOffset = function (player) {\n            player = player || self._currentPlayer;\n            if (player.getSubtitleOffset) {\n                return player.getSubtitleOffset();\n            }\n        };\n\n        self.canHandleOffsetOnCurrentSubtitle = function (player) {\n            const index = self.getSubtitleStreamIndex(player);\n            return index !== -1 && self.isSubtitleStreamExternal(index, player);\n        };\n\n        self.seek = function (ticks, player) {\n            ticks = Math.max(0, ticks);\n\n            player = player || self._currentPlayer;\n            if (player && !enableLocalPlaylistManagement(player)) {\n                if (player.isLocalPlayer) {\n                    return player.seek((ticks || 0) / 10000);\n                } else {\n                    return player.seek(ticks);\n                }\n            }\n\n            changeStream(player, ticks);\n        };\n\n        self.seekRelative = function (offsetTicks, player) {\n            player = player || self._currentPlayer;\n            if (player && !enableLocalPlaylistManagement(player) && player.seekRelative) {\n                if (player.isLocalPlayer) {\n                    return player.seekRelative((ticks || 0) / 10000);\n                } else {\n                    return player.seekRelative(ticks);\n                }\n            }\n\n            const ticks = getCurrentTicks(player) + offsetTicks;\n            return this.seek(ticks, player);\n        };\n\n        // Returns true if the player can seek using native client-side seeking functions\n        function canPlayerSeek(player) {\n            if (!player) {\n                throw new Error('player cannot be null');\n            }\n\n            const playerData = getPlayerData(player);\n\n            const currentSrc = (playerData.streamInfo.url || '').toLowerCase();\n\n            if (currentSrc.indexOf('.m3u8') !== -1) {\n                return true;\n            }\n\n            if (player.seekable) {\n                return player.seekable();\n            }\n\n            const isPlayMethodTranscode = self.playMethod(player) === 'Transcode';\n\n            if (isPlayMethodTranscode) {\n                return false;\n            }\n\n            return player.duration();\n        }\n\n        function changeStream(player, ticks, params) {\n            if (canPlayerSeek(player) && params == null) {\n                player.currentTime(parseInt(ticks / 10000));\n                return;\n            }\n\n            params = params || {};\n\n            const liveStreamId = getPlayerData(player).streamInfo.liveStreamId;\n            const lastMediaInfoQuery = getPlayerData(player).streamInfo.lastMediaInfoQuery;\n\n            const playSessionId = self.playSessionId(player);\n\n            const currentItem = self.currentItem(player);\n\n            player.getDeviceProfile(currentItem, {\n                isRetry: params.EnableDirectPlay === false\n            }).then(function (deviceProfile) {\n                const audioStreamIndex = params.AudioStreamIndex == null ? getPlayerData(player).audioStreamIndex : params.AudioStreamIndex;\n                const subtitleStreamIndex = params.SubtitleStreamIndex == null ? getPlayerData(player).subtitleStreamIndex : params.SubtitleStreamIndex;\n\n                let currentMediaSource = self.currentMediaSource(player);\n                const apiClient = connectionManager.getApiClient(currentItem.ServerId);\n\n                if (ticks) {\n                    ticks = parseInt(ticks);\n                }\n\n                const maxBitrate = params.MaxStreamingBitrate || self.getMaxStreamingBitrate(player);\n\n                const currentPlayOptions = currentItem.playOptions || getDefaultPlayOptions();\n\n                getPlaybackInfo(player, apiClient, currentItem, deviceProfile, maxBitrate, ticks, true, currentMediaSource.Id, audioStreamIndex, subtitleStreamIndex, liveStreamId, params.EnableDirectPlay, params.EnableDirectStream, params.AllowVideoStreamCopy, params.AllowAudioStreamCopy).then(function (result) {\n                    if (validatePlaybackInfoResult(self, result)) {\n                        currentMediaSource = result.MediaSources[0];\n\n                        const streamInfo = createStreamInfo(apiClient, currentItem.MediaType, currentItem, currentMediaSource, ticks);\n                        streamInfo.fullscreen = currentPlayOptions.fullscreen;\n                        streamInfo.lastMediaInfoQuery = lastMediaInfoQuery;\n\n                        if (!streamInfo.url) {\n                            showPlaybackInfoErrorMessage(self, 'NoCompatibleStream', true);\n                            return;\n                        }\n\n                        getPlayerData(player).subtitleStreamIndex = subtitleStreamIndex;\n                        getPlayerData(player).audioStreamIndex = audioStreamIndex;\n                        getPlayerData(player).maxStreamingBitrate = maxBitrate;\n\n                        changeStreamToUrl(apiClient, player, playSessionId, streamInfo);\n                    }\n                });\n            });\n        }\n\n        function changeStreamToUrl(apiClient, player, playSessionId, streamInfo, newPositionTicks) {\n            const playerData = getPlayerData(player);\n\n            playerData.isChangingStream = true;\n\n            if (playerData.streamInfo && playSessionId) {\n                apiClient.stopActiveEncodings(playSessionId).then(function () {\n                    // Stop the first transcoding afterwards because the player may still send requests to the original url\n                    const afterSetSrc = function () {\n                        apiClient.stopActiveEncodings(playSessionId);\n                    };\n                    setSrcIntoPlayer(apiClient, player, streamInfo).then(afterSetSrc, afterSetSrc);\n                });\n            } else {\n                setSrcIntoPlayer(apiClient, player, streamInfo);\n            }\n        }\n\n        function setSrcIntoPlayer(apiClient, player, streamInfo) {\n            return player.play(streamInfo).then(function () {\n                const playerData = getPlayerData(player);\n\n                playerData.isChangingStream = false;\n                playerData.streamInfo = streamInfo;\n                streamInfo.started = true;\n                streamInfo.ended = false;\n\n                sendProgressUpdate(player, 'timeupdate');\n            }, function (e) {\n                const playerData = getPlayerData(player);\n                playerData.isChangingStream = false;\n\n                onPlaybackError.call(player, e, {\n                    type: 'mediadecodeerror',\n                    streamInfo: streamInfo\n                });\n            });\n        }\n\n        function translateItemsForPlayback(items, options) {\n            if (items.length > 1 && options && options.ids) {\n                // Use the original request id array for sorting the result in the proper order\n                items.sort(function (a, b) {\n                    return options.ids.indexOf(a.Id) - options.ids.indexOf(b.Id);\n                });\n            }\n\n            const firstItem = items[0];\n            let promise;\n\n            const serverId = firstItem.ServerId;\n\n            const queryOptions = options.queryOptions || {};\n\n            if (firstItem.Type === 'Program') {\n                promise = getItemsForPlayback(serverId, {\n                    Ids: firstItem.ChannelId\n                });\n            } else if (firstItem.Type === 'Playlist') {\n                promise = getItemsForPlayback(serverId, {\n                    ParentId: firstItem.Id,\n                    SortBy: options.shuffle ? 'Random' : null\n                });\n            } else if (firstItem.Type === 'MusicArtist') {\n                promise = getItemsForPlayback(serverId, {\n                    ArtistIds: firstItem.Id,\n                    Filters: 'IsNotFolder',\n                    Recursive: true,\n                    SortBy: options.shuffle ? 'Random' : 'SortName',\n                    MediaTypes: 'Audio'\n                });\n            } else if (firstItem.MediaType === 'Photo') {\n                promise = getItemsForPlayback(serverId, {\n                    ParentId: firstItem.ParentId,\n                    Filters: 'IsNotFolder',\n                    // Setting this to true may cause some incorrect sorting\n                    Recursive: false,\n                    SortBy: options.shuffle ? 'Random' : 'SortName',\n                    MediaTypes: 'Photo,Video'\n                }).then(function (result) {\n                    const items = result.Items;\n\n                    let index = items.map(function (i) {\n                        return i.Id;\n                    }).indexOf(firstItem.Id);\n\n                    if (index === -1) {\n                        index = 0;\n                    }\n\n                    options.startIndex = index;\n\n                    return Promise.resolve(result);\n                });\n            } else if (firstItem.Type === 'PhotoAlbum') {\n                promise = getItemsForPlayback(serverId, {\n                    ParentId: firstItem.Id,\n                    Filters: 'IsNotFolder',\n                    // Setting this to true may cause some incorrect sorting\n                    Recursive: false,\n                    SortBy: options.shuffle ? 'Random' : 'SortName',\n                    MediaTypes: 'Photo,Video',\n                    Limit: 1000\n                });\n            } else if (firstItem.Type === 'MusicGenre') {\n                promise = getItemsForPlayback(serverId, {\n                    GenreIds: firstItem.Id,\n                    Filters: 'IsNotFolder',\n                    Recursive: true,\n                    SortBy: options.shuffle ? 'Random' : 'SortName',\n                    MediaTypes: 'Audio'\n                });\n            } else if (firstItem.IsFolder) {\n                promise = getItemsForPlayback(serverId, mergePlaybackQueries({\n                    ParentId: firstItem.Id,\n                    Filters: 'IsNotFolder',\n                    Recursive: true,\n                    // These are pre-sorted\n                    SortBy: options.shuffle ? 'Random' : (['BoxSet'].indexOf(firstItem.Type) === -1 ? 'SortName' : null),\n                    MediaTypes: 'Audio,Video'\n                }, queryOptions));\n            } else if (firstItem.Type === 'Episode' && items.length === 1 && getPlayer(firstItem, options).supportsProgress !== false) {\n                promise = new Promise(function (resolve, reject) {\n                    const apiClient = connectionManager.getApiClient(firstItem.ServerId);\n\n                    apiClient.getCurrentUser().then(function (user) {\n                        if (!user.Configuration.EnableNextEpisodeAutoPlay || !firstItem.SeriesId) {\n                            resolve(null);\n                            return;\n                        }\n\n                        apiClient.getEpisodes(firstItem.SeriesId, {\n                            IsVirtualUnaired: false,\n                            IsMissing: false,\n                            UserId: apiClient.getCurrentUserId(),\n                            Fields: 'Chapters'\n                        }).then(function (episodesResult) {\n                            let foundItem = false;\n                            episodesResult.Items = episodesResult.Items.filter(function (e) {\n                                if (foundItem) {\n                                    return true;\n                                }\n                                if (e.Id === firstItem.Id) {\n                                    foundItem = true;\n                                    return true;\n                                }\n\n                                return false;\n                            });\n                            episodesResult.TotalRecordCount = episodesResult.Items.length;\n                            resolve(episodesResult);\n                        }, reject);\n                    });\n                });\n            }\n\n            if (promise) {\n                return promise.then(function (result) {\n                    return result ? result.Items : items;\n                });\n            } else {\n                return Promise.resolve(items);\n            }\n        }\n\n        self.play = function (options) {\n            normalizePlayOptions(options);\n\n            if (self._currentPlayer) {\n                if (options.enableRemotePlayers === false && !self._currentPlayer.isLocalPlayer) {\n                    return Promise.reject();\n                }\n\n                if (!self._currentPlayer.isLocalPlayer) {\n                    return self._currentPlayer.play(options);\n                }\n            }\n\n            if (options.fullscreen) {\n                loading.show();\n            }\n\n            if (options.items) {\n                return translateItemsForPlayback(options.items, options).then(function (items) {\n                    return playWithIntros(items, options);\n                });\n            } else {\n                if (!options.serverId) {\n                    throw new Error('serverId required!');\n                }\n\n                return getItemsForPlayback(options.serverId, {\n                    Ids: options.ids.join(',')\n                }).then(function (result) {\n                    return translateItemsForPlayback(result.Items, options).then(function (items) {\n                        return playWithIntros(items, options);\n                    });\n                });\n            }\n        };\n\n        function getPlayerData(player) {\n            if (!player) {\n                throw new Error('player cannot be null');\n            }\n            if (!player.name) {\n                throw new Error('player name cannot be null');\n            }\n            let state = playerStates[player.name];\n\n            if (!state) {\n                playerStates[player.name] = {};\n                state = playerStates[player.name];\n            }\n\n            return player;\n        }\n\n        self.getPlayerState = function (player, item, mediaSource) {\n            player = player || self._currentPlayer;\n\n            if (!player) {\n                throw new Error('player cannot be null');\n            }\n\n            if (!enableLocalPlaylistManagement(player) && player.getPlayerState) {\n                return player.getPlayerState();\n            }\n\n            item = item || self.currentItem(player);\n            mediaSource = mediaSource || self.currentMediaSource(player);\n\n            const state = {\n                PlayState: {}\n            };\n\n            if (player) {\n                state.PlayState.VolumeLevel = player.getVolume();\n                state.PlayState.IsMuted = player.isMuted();\n                state.PlayState.IsPaused = player.paused();\n                state.PlayState.RepeatMode = self.getRepeatMode(player);\n                state.PlayState.ShuffleMode = self.getQueueShuffleMode(player);\n                state.PlayState.MaxStreamingBitrate = self.getMaxStreamingBitrate(player);\n\n                state.PlayState.PositionTicks = getCurrentTicks(player);\n                state.PlayState.PlaybackStartTimeTicks = self.playbackStartTime(player);\n\n                state.PlayState.SubtitleStreamIndex = self.getSubtitleStreamIndex(player);\n                state.PlayState.AudioStreamIndex = self.getAudioStreamIndex(player);\n                state.PlayState.BufferedRanges = self.getBufferedRanges(player);\n\n                state.PlayState.PlayMethod = self.playMethod(player);\n\n                if (mediaSource) {\n                    state.PlayState.LiveStreamId = mediaSource.LiveStreamId;\n                }\n                state.PlayState.PlaySessionId = self.playSessionId(player);\n                state.PlayState.PlaylistItemId = self.getCurrentPlaylistItemId(player);\n            }\n\n            if (mediaSource) {\n                state.PlayState.MediaSourceId = mediaSource.Id;\n\n                state.NowPlayingItem = {\n                    RunTimeTicks: mediaSource.RunTimeTicks\n                };\n\n                state.PlayState.CanSeek = (mediaSource.RunTimeTicks || 0) > 0 || canPlayerSeek(player);\n            }\n\n            if (item) {\n                state.NowPlayingItem = getNowPlayingItemForReporting(player, item, mediaSource);\n            }\n\n            state.MediaSource = mediaSource;\n\n            return state;\n        };\n\n        self.duration = function (player) {\n            player = player || self._currentPlayer;\n\n            if (player && !enableLocalPlaylistManagement(player) && !player.isLocalPlayer) {\n                return player.duration();\n            }\n\n            if (!player) {\n                throw new Error('player cannot be null');\n            }\n\n            const mediaSource = self.currentMediaSource(player);\n\n            if (mediaSource && mediaSource.RunTimeTicks) {\n                return mediaSource.RunTimeTicks;\n            }\n\n            let playerDuration = player.duration();\n\n            if (playerDuration) {\n                playerDuration *= 10000;\n            }\n\n            return playerDuration;\n        };\n\n        function getCurrentTicks(player) {\n            if (!player) {\n                throw new Error('player cannot be null');\n            }\n\n            let playerTime = Math.floor(10000 * (player).currentTime());\n\n            const streamInfo = getPlayerData(player).streamInfo;\n            if (streamInfo) {\n                playerTime += getPlayerData(player).streamInfo.transcodingOffsetTicks || 0;\n            }\n\n            return playerTime;\n        }\n\n        // Only used internally\n        self.getCurrentTicks = getCurrentTicks;\n\n        function playOther(items, options, user) {\n            const playStartIndex = options.startIndex || 0;\n            const player = getPlayer(items[playStartIndex], options);\n\n            loading.hide();\n\n            options.items = items;\n\n            return player.play(options);\n        }\n\n        function playWithIntros(items, options, user) {\n            let playStartIndex = options.startIndex || 0;\n            let firstItem = items[playStartIndex];\n\n            // If index was bad, reset it\n            if (!firstItem) {\n                playStartIndex = 0;\n                firstItem = items[playStartIndex];\n            }\n\n            // If it's still null then there's nothing to play\n            if (!firstItem) {\n                showPlaybackInfoErrorMessage(self, 'NoCompatibleStream', false);\n                return Promise.reject();\n            }\n\n            if (firstItem.MediaType === 'Photo' || firstItem.MediaType === 'Book') {\n                return playOther(items, options, user);\n            }\n\n            const apiClient = connectionManager.getApiClient(firstItem.ServerId);\n\n            return getIntros(firstItem, apiClient, options).then(function (introsResult) {\n                const introItems = introsResult.Items;\n                let introPlayOptions;\n\n                firstItem.playOptions = truncatePlayOptions(options);\n\n                if (introItems.length) {\n                    introPlayOptions = {\n                        fullscreen: firstItem.playOptions.fullscreen\n                    };\n                } else {\n                    introPlayOptions = firstItem.playOptions;\n                }\n\n                items = introItems.concat(items);\n\n                // Needed by players that manage their own playlist\n                introPlayOptions.items = items;\n                introPlayOptions.startIndex = playStartIndex;\n\n                return playInternal(items[playStartIndex], introPlayOptions, function () {\n                    self._playQueueManager.setPlaylist(items);\n\n                    setPlaylistState(items[playStartIndex].PlaylistItemId, playStartIndex);\n                    loading.hide();\n                });\n            });\n        }\n\n        // Set playlist state. Using a method allows for overloading in derived player implementations\n        function setPlaylistState(playlistItemId, index) {\n            if (!isNaN(index)) {\n                self._playQueueManager.setPlaylistState(playlistItemId, index);\n            }\n        }\n\n        function playInternal(item, playOptions, onPlaybackStartedFn) {\n            if (item.IsPlaceHolder) {\n                loading.hide();\n                showPlaybackInfoErrorMessage(self, 'PlaceHolder', true);\n                return Promise.reject();\n            }\n\n            // Normalize defaults to simplfy checks throughout the process\n            normalizePlayOptions(playOptions);\n\n            if (playOptions.isFirstItem) {\n                playOptions.isFirstItem = false;\n            } else {\n                playOptions.isFirstItem = true;\n            }\n\n            return runInterceptors(item, playOptions).then(function () {\n                if (playOptions.fullscreen) {\n                    loading.show();\n                }\n\n                // TODO: This should be the media type requested, not the original media type\n                const mediaType = item.MediaType;\n\n                const onBitrateDetectionFailure = function () {\n                    return playAfterBitrateDetect(getSavedMaxStreamingBitrate(connectionManager.getApiClient(item.ServerId), mediaType), item, playOptions, onPlaybackStartedFn);\n                };\n\n                if (!isServerItem(item) || itemHelper.isLocalItem(item)) {\n                    return onBitrateDetectionFailure();\n                }\n\n                const apiClient = connectionManager.getApiClient(item.ServerId);\n                apiClient.getEndpointInfo().then(function (endpointInfo) {\n                    if ((mediaType === 'Video' || mediaType === 'Audio') && appSettings.enableAutomaticBitrateDetection(endpointInfo.IsInNetwork, mediaType)) {\n                        return apiClient.detectBitrate().then(function (bitrate) {\n                            appSettings.maxStreamingBitrate(endpointInfo.IsInNetwork, mediaType, bitrate);\n\n                            return playAfterBitrateDetect(bitrate, item, playOptions, onPlaybackStartedFn);\n                        }, onBitrateDetectionFailure);\n                    } else {\n                        onBitrateDetectionFailure();\n                    }\n                }, onBitrateDetectionFailure);\n            }, onInterceptorRejection);\n        }\n\n        function onInterceptorRejection() {\n            const player = self._currentPlayer;\n\n            if (player) {\n                destroyPlayer(player);\n                removeCurrentPlayer(player);\n            }\n\n            events.trigger(self, 'playbackcancelled');\n\n            return Promise.reject();\n        }\n\n        function destroyPlayer(player) {\n            player.destroy();\n        }\n\n        function runInterceptors(item, playOptions) {\n            return new Promise(function (resolve, reject) {\n                const interceptors = pluginManager.ofType('preplayintercept');\n\n                interceptors.sort(function (a, b) {\n                    return (a.order || 0) - (b.order || 0);\n                });\n\n                if (!interceptors.length) {\n                    resolve();\n                    return;\n                }\n\n                loading.hide();\n\n                const options = Object.assign({}, playOptions);\n\n                options.mediaType = item.MediaType;\n                options.item = item;\n\n                runNextPrePlay(interceptors, 0, options, resolve, reject);\n            });\n        }\n\n        function runNextPrePlay(interceptors, index, options, resolve, reject) {\n            if (index >= interceptors.length) {\n                resolve();\n                return;\n            }\n\n            const interceptor = interceptors[index];\n\n            interceptor.intercept(options).then(function () {\n                runNextPrePlay(interceptors, index + 1, options, resolve, reject);\n            }, reject);\n        }\n\n        function sendPlaybackListToPlayer(player, items, deviceProfile, maxBitrate, apiClient, startPositionTicks, mediaSourceId, audioStreamIndex, subtitleStreamIndex, startIndex) {\n            return setStreamUrls(items, deviceProfile, maxBitrate, apiClient, startPositionTicks).then(function () {\n                loading.hide();\n\n                return player.play({\n                    items: items,\n                    startPositionTicks: startPositionTicks || 0,\n                    mediaSourceId: mediaSourceId,\n                    audioStreamIndex: audioStreamIndex,\n                    subtitleStreamIndex: subtitleStreamIndex,\n                    startIndex: startIndex\n                });\n            });\n        }\n\n        function playAfterBitrateDetect(maxBitrate, item, playOptions, onPlaybackStartedFn) {\n            const startPosition = playOptions.startPositionTicks;\n\n            const player = getPlayer(item, playOptions);\n            const activePlayer = self._currentPlayer;\n\n            let promise;\n\n            if (activePlayer) {\n                // TODO: if changing players within the same playlist, this will cause nextItem to be null\n                self._playNextAfterEnded = false;\n                promise = onPlaybackChanging(activePlayer, player, item);\n            } else {\n                promise = Promise.resolve();\n            }\n\n            if (!isServerItem(item) || item.MediaType === 'Book') {\n                return promise.then(function () {\n                    const streamInfo = createStreamInfoFromUrlItem(item);\n                    streamInfo.fullscreen = playOptions.fullscreen;\n                    getPlayerData(player).isChangingStream = false;\n                    return player.play(streamInfo).then(function () {\n                        loading.hide();\n                        onPlaybackStartedFn();\n                        onPlaybackStarted(player, playOptions, streamInfo);\n                    }, function () {\n                        // TODO: show error message\n                        self.stop(player);\n                    });\n                });\n            }\n\n            return Promise.all([promise, player.getDeviceProfile(item)]).then(function (responses) {\n                const deviceProfile = responses[1];\n\n                const apiClient = connectionManager.getApiClient(item.ServerId);\n\n                const mediaSourceId = playOptions.mediaSourceId;\n                const audioStreamIndex = playOptions.audioStreamIndex;\n                const subtitleStreamIndex = playOptions.subtitleStreamIndex;\n\n                if (player && !enableLocalPlaylistManagement(player)) {\n                    return sendPlaybackListToPlayer(player, playOptions.items, deviceProfile, maxBitrate, apiClient, startPosition, mediaSourceId, audioStreamIndex, subtitleStreamIndex, playOptions.startIndex);\n                }\n\n                // this reference was only needed by sendPlaybackListToPlayer\n                playOptions.items = null;\n\n                return getPlaybackMediaSource(player, apiClient, deviceProfile, maxBitrate, item, startPosition, mediaSourceId, audioStreamIndex, subtitleStreamIndex).then(function (mediaSource) {\n                    const streamInfo = createStreamInfo(apiClient, item.MediaType, item, mediaSource, startPosition);\n\n                    streamInfo.fullscreen = playOptions.fullscreen;\n\n                    getPlayerData(player).isChangingStream = false;\n                    getPlayerData(player).maxStreamingBitrate = maxBitrate;\n\n                    return player.play(streamInfo).then(function () {\n                        loading.hide();\n                        onPlaybackStartedFn();\n                        onPlaybackStarted(player, playOptions, streamInfo, mediaSource);\n                    }, function (err) {\n                        // TODO: Improve this because it will report playback start on a failure\n                        onPlaybackStartedFn();\n                        onPlaybackStarted(player, playOptions, streamInfo, mediaSource);\n                        setTimeout(function () {\n                            onPlaybackError.call(player, err, {\n                                type: 'mediadecodeerror',\n                                streamInfo: streamInfo\n                            });\n                        }, 100);\n                    });\n                });\n            });\n        }\n\n        self.getPlaybackInfo = function (item, options) {\n            options = options || {};\n            const startPosition = options.startPositionTicks || 0;\n            const mediaType = options.mediaType || item.MediaType;\n            const player = getPlayer(item, options);\n            const apiClient = connectionManager.getApiClient(item.ServerId);\n\n            // Call this just to ensure the value is recorded, it is needed with getSavedMaxStreamingBitrate\n            return apiClient.getEndpointInfo().then(function () {\n                const maxBitrate = getSavedMaxStreamingBitrate(connectionManager.getApiClient(item.ServerId), mediaType);\n\n                return player.getDeviceProfile(item).then(function (deviceProfile) {\n                    return getPlaybackMediaSource(player, apiClient, deviceProfile, maxBitrate, item, startPosition, options.mediaSourceId, options.audioStreamIndex, options.subtitleStreamIndex).then(function (mediaSource) {\n                        return createStreamInfo(apiClient, item.MediaType, item, mediaSource, startPosition);\n                    });\n                });\n            });\n        };\n\n        self.getPlaybackMediaSources = function (item, options) {\n            options = options || {};\n            const startPosition = options.startPositionTicks || 0;\n            const mediaType = options.mediaType || item.MediaType;\n            // TODO: Remove the true forceLocalPlayer hack\n            const player = getPlayer(item, options, true);\n            const apiClient = connectionManager.getApiClient(item.ServerId);\n\n            // Call this just to ensure the value is recorded, it is needed with getSavedMaxStreamingBitrate\n            return apiClient.getEndpointInfo().then(function () {\n                const maxBitrate = getSavedMaxStreamingBitrate(connectionManager.getApiClient(item.ServerId), mediaType);\n\n                return player.getDeviceProfile(item).then(function (deviceProfile) {\n                    return getPlaybackInfo(player, apiClient, item, deviceProfile, maxBitrate, startPosition, false, null, null, null, null).then(function (playbackInfoResult) {\n                        return playbackInfoResult.MediaSources;\n                    });\n                });\n            });\n        };\n\n        function createStreamInfo(apiClient, type, item, mediaSource, startPosition) {\n            let mediaUrl;\n            let contentType;\n            let transcodingOffsetTicks = 0;\n            const playerStartPositionTicks = startPosition;\n            const liveStreamId = mediaSource.LiveStreamId;\n\n            let playMethod = 'Transcode';\n\n            const mediaSourceContainer = (mediaSource.Container || '').toLowerCase();\n            let directOptions;\n\n            if (type === 'Video' || type === 'Audio') {\n                contentType = getMimeType(type.toLowerCase(), mediaSourceContainer);\n\n                if (mediaSource.enableDirectPlay) {\n                    mediaUrl = mediaSource.Path;\n\n                    playMethod = 'DirectPlay';\n                } else if (mediaSource.StreamUrl) {\n                    // Only used for audio\n                    playMethod = 'Transcode';\n                    mediaUrl = mediaSource.StreamUrl;\n                } else if (mediaSource.SupportsDirectStream) {\n                    directOptions = {\n                        Static: true,\n                        mediaSourceId: mediaSource.Id,\n                        deviceId: apiClient.deviceId(),\n                        api_key: apiClient.accessToken()\n                    };\n\n                    if (mediaSource.ETag) {\n                        directOptions.Tag = mediaSource.ETag;\n                    }\n\n                    if (mediaSource.LiveStreamId) {\n                        directOptions.LiveStreamId = mediaSource.LiveStreamId;\n                    }\n\n                    const prefix = type === 'Video' ? 'Videos' : 'Audio';\n                    mediaUrl = apiClient.getUrl(prefix + '/' + item.Id + '/stream.' + mediaSourceContainer, directOptions);\n\n                    playMethod = 'DirectStream';\n                } else if (mediaSource.SupportsTranscoding) {\n                    mediaUrl = apiClient.getUrl(mediaSource.TranscodingUrl);\n\n                    if (mediaSource.TranscodingSubProtocol === 'hls') {\n                        contentType = 'application/x-mpegURL';\n                    } else {\n                        contentType = getMimeType(type.toLowerCase(), mediaSource.TranscodingContainer);\n\n                        if (mediaUrl.toLowerCase().indexOf('copytimestamps=true') === -1) {\n                            transcodingOffsetTicks = startPosition || 0;\n                        }\n                    }\n                }\n            } else {\n                // All other media types\n                mediaUrl = mediaSource.Path;\n                playMethod = 'DirectPlay';\n            }\n\n            // Fallback (used for offline items)\n            if (!mediaUrl && mediaSource.SupportsDirectPlay) {\n                mediaUrl = mediaSource.Path;\n                playMethod = 'DirectPlay';\n            }\n\n            const resultInfo = {\n                url: mediaUrl,\n                mimeType: contentType,\n                transcodingOffsetTicks: transcodingOffsetTicks,\n                playMethod: playMethod,\n                playerStartPositionTicks: playerStartPositionTicks,\n                item: item,\n                mediaSource: mediaSource,\n                textTracks: getTextTracks(apiClient, item, mediaSource),\n                // TODO: Deprecate\n                tracks: getTextTracks(apiClient, item, mediaSource),\n                mediaType: type,\n                liveStreamId: liveStreamId,\n                playSessionId: getParam('playSessionId', mediaUrl),\n                title: item.Name\n            };\n\n            const backdropUrl = backdropImageUrl(apiClient, item, {});\n            if (backdropUrl) {\n                resultInfo.backdropUrl = backdropUrl;\n            }\n\n            return resultInfo;\n        }\n\n        function getTextTracks(apiClient, item, mediaSource) {\n            const subtitleStreams = mediaSource.MediaStreams.filter(function (s) {\n                return s.Type === 'Subtitle';\n            });\n\n            const textStreams = subtitleStreams.filter(function (s) {\n                return s.DeliveryMethod === 'External';\n            });\n\n            const tracks = [];\n\n            for (let i = 0, length = textStreams.length; i < length; i++) {\n                const textStream = textStreams[i];\n                let textStreamUrl;\n\n                if (itemHelper.isLocalItem(item)) {\n                    textStreamUrl = textStream.Path;\n                } else {\n                    textStreamUrl = !textStream.IsExternalUrl ? apiClient.getUrl(textStream.DeliveryUrl) : textStream.DeliveryUrl;\n                }\n\n                tracks.push({\n                    url: textStreamUrl,\n                    language: (textStream.Language || 'und'),\n                    isDefault: textStream.Index === mediaSource.DefaultSubtitleStreamIndex,\n                    index: textStream.Index,\n                    format: textStream.Codec\n                });\n            }\n\n            return tracks;\n        }\n\n        function getPlaybackMediaSource(player, apiClient, deviceProfile, maxBitrate, item, startPosition, mediaSourceId, audioStreamIndex, subtitleStreamIndex) {\n            return getPlaybackInfo(player, apiClient, item, deviceProfile, maxBitrate, startPosition, true, mediaSourceId, audioStreamIndex, subtitleStreamIndex, null).then(function (playbackInfoResult) {\n                if (validatePlaybackInfoResult(self, playbackInfoResult)) {\n                    return getOptimalMediaSource(apiClient, item, playbackInfoResult.MediaSources).then(function (mediaSource) {\n                        if (mediaSource) {\n                            if (mediaSource.RequiresOpening && !mediaSource.LiveStreamId) {\n                                return getLiveStream(player, apiClient, item, playbackInfoResult.PlaySessionId, deviceProfile, maxBitrate, startPosition, mediaSource, null, null).then(function (openLiveStreamResult) {\n                                    return supportsDirectPlay(apiClient, item, openLiveStreamResult.MediaSource).then(function (result) {\n                                        openLiveStreamResult.MediaSource.enableDirectPlay = result;\n                                        return openLiveStreamResult.MediaSource;\n                                    });\n                                });\n                            } else {\n                                return mediaSource;\n                            }\n                        } else {\n                            showPlaybackInfoErrorMessage(self, 'NoCompatibleStream');\n                            return Promise.reject();\n                        }\n                    });\n                } else {\n                    return Promise.reject();\n                }\n            });\n        }\n\n        function getPlayer(item, playOptions, forceLocalPlayers) {\n            const serverItem = isServerItem(item);\n            return getAutomaticPlayers(self, forceLocalPlayers).filter(function (p) {\n                if (p.canPlayMediaType(item.MediaType)) {\n                    if (serverItem) {\n                        if (p.canPlayItem) {\n                            return p.canPlayItem(item, playOptions);\n                        }\n                        return true;\n                    } else if (item.Url && p.canPlayUrl) {\n                        return p.canPlayUrl(item.Url);\n                    }\n                }\n\n                return false;\n            })[0];\n        }\n\n        self.setCurrentPlaylistItem = function (playlistItemId, player) {\n            player = player || self._currentPlayer;\n            if (player && !enableLocalPlaylistManagement(player)) {\n                return player.setCurrentPlaylistItem(playlistItemId);\n            }\n\n            let newItem;\n            let newItemIndex;\n            const playlist = self._playQueueManager.getPlaylist();\n\n            for (let i = 0, length = playlist.length; i < length; i++) {\n                if (playlist[i].PlaylistItemId === playlistItemId) {\n                    newItem = playlist[i];\n                    newItemIndex = i;\n                    break;\n                }\n            }\n\n            if (newItem) {\n                const newItemPlayOptions = newItem.playOptions || getDefaultPlayOptions();\n\n                playInternal(newItem, newItemPlayOptions, function () {\n                    setPlaylistState(newItem.PlaylistItemId, newItemIndex);\n                });\n            }\n        };\n\n        self.removeFromPlaylist = function (playlistItemIds, player) {\n            if (!playlistItemIds) {\n                throw new Error('Invalid playlistItemIds');\n            }\n\n            player = player || self._currentPlayer;\n            if (player && !enableLocalPlaylistManagement(player)) {\n                return player.removeFromPlaylist(playlistItemIds);\n            }\n\n            const removeResult = self._playQueueManager.removeFromPlaylist(playlistItemIds);\n\n            if (removeResult.result === 'empty') {\n                return self.stop(player);\n            }\n\n            const isCurrentIndex = removeResult.isCurrentIndex;\n\n            events.trigger(player, 'playlistitemremove', [\n                {\n                    playlistItemIds: playlistItemIds\n                }\n            ]);\n\n            if (isCurrentIndex) {\n                return self.setCurrentPlaylistItem(self._playQueueManager.getPlaylist()[0].PlaylistItemId, player);\n            }\n\n            return Promise.resolve();\n        };\n\n        self.movePlaylistItem = function (playlistItemId, newIndex, player) {\n            player = player || self._currentPlayer;\n            if (player && !enableLocalPlaylistManagement(player)) {\n                return player.movePlaylistItem(playlistItemId, newIndex);\n            }\n\n            const moveResult = self._playQueueManager.movePlaylistItem(playlistItemId, newIndex);\n\n            if (moveResult.result === 'noop') {\n                return;\n            }\n\n            events.trigger(player, 'playlistitemmove', [\n                {\n                    playlistItemId: moveResult.playlistItemId,\n                    newIndex: moveResult.newIndex\n                }\n            ]);\n        };\n\n        self.getCurrentPlaylistIndex = function (player) {\n            player = player || self._currentPlayer;\n            if (player && !enableLocalPlaylistManagement(player)) {\n                return player.getCurrentPlaylistIndex();\n            }\n\n            return self._playQueueManager.getCurrentPlaylistIndex();\n        };\n\n        self.getCurrentPlaylistItemId = function (player) {\n            player = player || self._currentPlayer;\n            if (player && !enableLocalPlaylistManagement(player)) {\n                return player.getCurrentPlaylistItemId();\n            }\n\n            return self._playQueueManager.getCurrentPlaylistItemId();\n        };\n\n        self.channelUp = function (player) {\n            player = player || self._currentPlayer;\n            return self.nextTrack(player);\n        };\n\n        self.channelDown = function (player) {\n            player = player || self._currentPlayer;\n            return self.previousTrack(player);\n        };\n\n        self.nextTrack = function (player) {\n            player = player || self._currentPlayer;\n            if (player && !enableLocalPlaylistManagement(player)) {\n                return player.nextTrack();\n            }\n\n            const newItemInfo = self._playQueueManager.getNextItemInfo();\n\n            if (newItemInfo) {\n                console.debug('playing next track');\n\n                const newItemPlayOptions = newItemInfo.item.playOptions || getDefaultPlayOptions();\n\n                playInternal(newItemInfo.item, newItemPlayOptions, function () {\n                    setPlaylistState(newItemInfo.item.PlaylistItemId, newItemInfo.index);\n                });\n            }\n        };\n\n        self.previousTrack = function (player) {\n            player = player || self._currentPlayer;\n            if (player && !enableLocalPlaylistManagement(player)) {\n                return player.previousTrack();\n            }\n\n            const newIndex = self.getCurrentPlaylistIndex(player) - 1;\n            if (newIndex >= 0) {\n                const playlist = self._playQueueManager.getPlaylist();\n                const newItem = playlist[newIndex];\n\n                if (newItem) {\n                    const newItemPlayOptions = newItem.playOptions || getDefaultPlayOptions();\n                    newItemPlayOptions.startPositionTicks = 0;\n\n                    playInternal(newItem, newItemPlayOptions, function () {\n                        setPlaylistState(newItem.PlaylistItemId, newIndex);\n                    });\n                }\n            }\n        };\n\n        self.queue = function (options, player = this._currentPlayer) {\n            queue(options, '', player);\n        };\n\n        self.queueNext = function (options, player = this._currentPlayer) {\n            queue(options, 'next', player);\n        };\n\n        function queue(options, mode, player) {\n            player = player || self._currentPlayer;\n\n            if (!player) {\n                return self.play(options);\n            }\n\n            if (options.items) {\n                return translateItemsForPlayback(options.items, options).then(function (items) {\n                    // TODO: Handle options.startIndex for photos\n                    queueAll(items, mode, player);\n                });\n            } else {\n                if (!options.serverId) {\n                    throw new Error('serverId required!');\n                }\n\n                return getItemsForPlayback(options.serverId, {\n                    Ids: options.ids.join(',')\n                }).then(function (result) {\n                    return translateItemsForPlayback(result.Items, options).then(function (items) {\n                        // TODO: Handle options.startIndex for photos\n                        queueAll(items, mode, player);\n                    });\n                });\n            }\n        }\n\n        function queueAll(items, mode, player) {\n            if (!items.length) {\n                return;\n            }\n\n            if (!player.isLocalPlayer) {\n                if (mode === 'next') {\n                    player.queueNext({\n                        items: items\n                    });\n                } else {\n                    player.queue({\n                        items: items\n                    });\n                }\n                return;\n            }\n\n            const queueDirectToPlayer = player && !enableLocalPlaylistManagement(player);\n\n            if (queueDirectToPlayer) {\n                const apiClient = connectionManager.getApiClient(items[0].ServerId);\n\n                player.getDeviceProfile(items[0]).then(function (profile) {\n                    setStreamUrls(items, profile, self.getMaxStreamingBitrate(player), apiClient, 0).then(function () {\n                        if (mode === 'next') {\n                            player.queueNext(items);\n                        } else {\n                            player.queue(items);\n                        }\n                    });\n                });\n\n                return;\n            }\n\n            if (mode === 'next') {\n                self._playQueueManager.queueNext(items);\n            } else {\n                self._playQueueManager.queue(items);\n            }\n            events.trigger(player, 'playlistitemadd');\n        }\n\n        function onPlayerProgressInterval() {\n            const player = this;\n            sendProgressUpdate(player, 'timeupdate');\n        }\n\n        function startPlaybackProgressTimer(player) {\n            stopPlaybackProgressTimer(player);\n\n            player._progressInterval = setInterval(onPlayerProgressInterval.bind(player), 10000);\n        }\n\n        function stopPlaybackProgressTimer(player) {\n            if (player._progressInterval) {\n                clearInterval(player._progressInterval);\n                player._progressInterval = null;\n            }\n        }\n\n        function onPlaybackStarted(player, playOptions, streamInfo, mediaSource) {\n            if (!player) {\n                throw new Error('player cannot be null');\n            }\n\n            setCurrentPlayerInternal(player);\n\n            const playerData = getPlayerData(player);\n\n            playerData.streamInfo = streamInfo;\n\n            streamInfo.playbackStartTimeTicks = new Date().getTime() * 10000;\n\n            if (mediaSource) {\n                playerData.audioStreamIndex = mediaSource.DefaultAudioStreamIndex;\n                playerData.subtitleStreamIndex = mediaSource.DefaultSubtitleStreamIndex;\n            } else {\n                playerData.audioStreamIndex = null;\n                playerData.subtitleStreamIndex = null;\n            }\n\n            self._playNextAfterEnded = true;\n            const isFirstItem = playOptions.isFirstItem;\n            const fullscreen = playOptions.fullscreen;\n\n            const state = self.getPlayerState(player, streamInfo.item, streamInfo.mediaSource);\n\n            reportPlayback(self, state, player, true, state.NowPlayingItem.ServerId, 'reportPlaybackStart');\n\n            state.IsFirstItem = isFirstItem;\n            state.IsFullscreen = fullscreen;\n            events.trigger(player, 'playbackstart', [state]);\n            events.trigger(self, 'playbackstart', [player, state]);\n\n            // only used internally as a safeguard to avoid reporting other events to the server before playback start\n            streamInfo.started = true;\n\n            startPlaybackProgressTimer(player);\n        }\n\n        function onPlaybackStartedFromSelfManagingPlayer(e, item, mediaSource) {\n            const player = this;\n            setCurrentPlayerInternal(player);\n\n            const playOptions = item.playOptions || getDefaultPlayOptions();\n            const isFirstItem = playOptions.isFirstItem;\n            const fullscreen = playOptions.fullscreen;\n\n            playOptions.isFirstItem = false;\n\n            const playerData = getPlayerData(player);\n            playerData.streamInfo = {};\n\n            const streamInfo = playerData.streamInfo;\n            streamInfo.playbackStartTimeTicks = new Date().getTime() * 10000;\n\n            const state = self.getPlayerState(player, item, mediaSource);\n\n            reportPlayback(self, state, player, true, state.NowPlayingItem.ServerId, 'reportPlaybackStart');\n\n            state.IsFirstItem = isFirstItem;\n            state.IsFullscreen = fullscreen;\n            events.trigger(player, 'playbackstart', [state]);\n            events.trigger(self, 'playbackstart', [player, state]);\n\n            // only used internally as a safeguard to avoid reporting other events to the server before playback start\n            streamInfo.started = true;\n\n            startPlaybackProgressTimer(player);\n        }\n\n        function onPlaybackStoppedFromSelfManagingPlayer(e, playerStopInfo) {\n            const player = this;\n\n            stopPlaybackProgressTimer(player);\n            const state = self.getPlayerState(player, playerStopInfo.item, playerStopInfo.mediaSource);\n\n            const nextItem = playerStopInfo.nextItem;\n            const nextMediaType = playerStopInfo.nextMediaType;\n\n            const playbackStopInfo = {\n                player: player,\n                state: state,\n                nextItem: (nextItem ? nextItem.item : null),\n                nextMediaType: nextMediaType\n            };\n\n            state.NextMediaType = nextMediaType;\n\n            const streamInfo = getPlayerData(player).streamInfo;\n\n            // only used internally as a safeguard to avoid reporting other events to the server after playback stopped\n            streamInfo.ended = true;\n\n            if (isServerItem(playerStopInfo.item)) {\n                state.PlayState.PositionTicks = (playerStopInfo.positionMs || 0) * 10000;\n\n                reportPlayback(self, state, player, true, playerStopInfo.item.ServerId, 'reportPlaybackStopped');\n            }\n\n            state.NextItem = playbackStopInfo.nextItem;\n\n            events.trigger(player, 'playbackstop', [state]);\n            events.trigger(self, 'playbackstop', [playbackStopInfo]);\n\n            const nextItemPlayOptions = nextItem ? (nextItem.item.playOptions || getDefaultPlayOptions()) : getDefaultPlayOptions();\n            const newPlayer = nextItem ? getPlayer(nextItem.item, nextItemPlayOptions) : null;\n\n            if (newPlayer !== player) {\n                destroyPlayer(player);\n                removeCurrentPlayer(player);\n            }\n        }\n\n        function enablePlaybackRetryWithTranscoding(streamInfo, errorType, currentlyPreventsVideoStreamCopy, currentlyPreventsAudioStreamCopy) {\n            // mediadecodeerror, medianotsupported, network, servererror\n            if (streamInfo.mediaSource.SupportsTranscoding && (!currentlyPreventsVideoStreamCopy || !currentlyPreventsAudioStreamCopy)) {\n                return true;\n            }\n\n            return false;\n        }\n\n        function onPlaybackError(e, error) {\n            const player = this;\n            error = error || {};\n\n            // network\n            // mediadecodeerror\n            // medianotsupported\n            const errorType = error.type;\n\n            console.debug('playbackmanager playback error type: ' + (errorType || ''));\n\n            const streamInfo = error.streamInfo || getPlayerData(player).streamInfo;\n\n            if (streamInfo) {\n                const currentlyPreventsVideoStreamCopy = streamInfo.url.toLowerCase().indexOf('allowvideostreamcopy=false') !== -1;\n                const currentlyPreventsAudioStreamCopy = streamInfo.url.toLowerCase().indexOf('allowaudiostreamcopy=false') !== -1;\n\n                // Auto switch to transcoding\n                if (enablePlaybackRetryWithTranscoding(streamInfo, errorType, currentlyPreventsVideoStreamCopy, currentlyPreventsAudioStreamCopy)) {\n                    const startTime = getCurrentTicks(player) || streamInfo.playerStartPositionTicks;\n\n                    changeStream(player, startTime, {\n                        // force transcoding\n                        EnableDirectPlay: false,\n                        EnableDirectStream: false,\n                        AllowVideoStreamCopy: false,\n                        AllowAudioStreamCopy: currentlyPreventsAudioStreamCopy || currentlyPreventsVideoStreamCopy ? false : null\n                    });\n\n                    return;\n                }\n            }\n\n            const displayErrorCode = 'NoCompatibleStream';\n            onPlaybackStopped.call(player, e, displayErrorCode);\n        }\n\n        function onPlaybackStopped(e, displayErrorCode) {\n            const player = this;\n\n            if (getPlayerData(player).isChangingStream) {\n                return;\n            }\n\n            stopPlaybackProgressTimer(player);\n\n            // User clicked stop or content ended\n            const state = self.getPlayerState(player);\n            const data = getPlayerData(player);\n            const streamInfo = data.streamInfo;\n\n            const nextItem = self._playNextAfterEnded ? self._playQueueManager.getNextItemInfo() : null;\n\n            const nextMediaType = (nextItem ? nextItem.item.MediaType : null);\n\n            const playbackStopInfo = {\n                player: player,\n                state: state,\n                nextItem: (nextItem ? nextItem.item : null),\n                nextMediaType: nextMediaType\n            };\n\n            state.NextMediaType = nextMediaType;\n\n            if (isServerItem(streamInfo.item)) {\n                if (player.supportsProgress === false && state.PlayState && !state.PlayState.PositionTicks) {\n                    state.PlayState.PositionTicks = streamInfo.item.RunTimeTicks;\n                }\n\n                // only used internally as a safeguard to avoid reporting other events to the server after playback stopped\n                streamInfo.ended = true;\n\n                reportPlayback(self, state, player, true, streamInfo.item.ServerId, 'reportPlaybackStopped');\n            }\n\n            state.NextItem = playbackStopInfo.nextItem;\n\n            if (!nextItem) {\n                self._playQueueManager.reset();\n            }\n\n            events.trigger(player, 'playbackstop', [state]);\n            events.trigger(self, 'playbackstop', [playbackStopInfo]);\n\n            const nextItemPlayOptions = nextItem ? (nextItem.item.playOptions || getDefaultPlayOptions()) : getDefaultPlayOptions();\n            const newPlayer = nextItem ? getPlayer(nextItem.item, nextItemPlayOptions) : null;\n\n            if (newPlayer !== player) {\n                destroyPlayer(player);\n                removeCurrentPlayer(player);\n            }\n\n            if (displayErrorCode && typeof (displayErrorCode) === 'string') {\n                showPlaybackInfoErrorMessage(self, displayErrorCode, nextItem);\n            } else if (nextItem) {\n                self.nextTrack();\n            } else {\n                // Nothing more to play - clear data\n                data.streamInfo = null;\n            }\n        }\n\n        function onPlaybackChanging(activePlayer, newPlayer, newItem) {\n            const state = self.getPlayerState(activePlayer);\n\n            const serverId = self.currentItem(activePlayer).ServerId;\n\n            // User started playing something new while existing content is playing\n            let promise;\n\n            stopPlaybackProgressTimer(activePlayer);\n            unbindStopped(activePlayer);\n\n            if (activePlayer === newPlayer) {\n                // If we're staying with the same player, stop it\n                promise = activePlayer.stop(false);\n            } else {\n                // If we're switching players, tear down the current one\n                promise = activePlayer.stop(true);\n            }\n\n            return promise.then(function () {\n                bindStopped(activePlayer);\n\n                if (enableLocalPlaylistManagement(activePlayer)) {\n                    reportPlayback(self, state, activePlayer, true, serverId, 'reportPlaybackStopped');\n                }\n\n                events.trigger(self, 'playbackstop', [{\n                    player: activePlayer,\n                    state: state,\n                    nextItem: newItem,\n                    nextMediaType: newItem.MediaType\n                }]);\n            });\n        }\n\n        function bindStopped(player) {\n            if (enableLocalPlaylistManagement(player)) {\n                events.off(player, 'stopped', onPlaybackStopped);\n                events.on(player, 'stopped', onPlaybackStopped);\n            }\n        }\n\n        function onPlaybackTimeUpdate(e) {\n            const player = this;\n            sendProgressUpdate(player, 'timeupdate');\n        }\n\n        function onPlaybackPause(e) {\n            const player = this;\n            sendProgressUpdate(player, 'pause');\n        }\n\n        function onPlaybackUnpause(e) {\n            const player = this;\n            sendProgressUpdate(player, 'unpause');\n        }\n\n        function onPlaybackVolumeChange(e) {\n            const player = this;\n            sendProgressUpdate(player, 'volumechange');\n        }\n\n        function onRepeatModeChange(e) {\n            const player = this;\n            sendProgressUpdate(player, 'repeatmodechange');\n        }\n\n        function onShuffleQueueModeChange() {\n            const player = this;\n            sendProgressUpdate(player, 'shufflequeuemodechange');\n        }\n\n        function onPlaylistItemMove(e) {\n            const player = this;\n            sendProgressUpdate(player, 'playlistitemmove', true);\n        }\n\n        function onPlaylistItemRemove(e) {\n            const player = this;\n            sendProgressUpdate(player, 'playlistitemremove', true);\n        }\n\n        function onPlaylistItemAdd(e) {\n            const player = this;\n            sendProgressUpdate(player, 'playlistitemadd', true);\n        }\n\n        function unbindStopped(player) {\n            events.off(player, 'stopped', onPlaybackStopped);\n        }\n\n        function initLegacyVolumeMethods(player) {\n            player.getVolume = function () {\n                return player.volume();\n            };\n            player.setVolume = function (val) {\n                return player.volume(val);\n            };\n        }\n\n        function initMediaPlayer(player) {\n            players.push(player);\n            players.sort(function (a, b) {\n                return (a.priority || 0) - (b.priority || 0);\n            });\n\n            if (player.isLocalPlayer !== false) {\n                player.isLocalPlayer = true;\n            }\n\n            player.currentState = {};\n\n            if (!player.getVolume || !player.setVolume) {\n                initLegacyVolumeMethods(player);\n            }\n\n            if (enableLocalPlaylistManagement(player)) {\n                events.on(player, 'error', onPlaybackError);\n                events.on(player, 'timeupdate', onPlaybackTimeUpdate);\n                events.on(player, 'pause', onPlaybackPause);\n                events.on(player, 'unpause', onPlaybackUnpause);\n                events.on(player, 'volumechange', onPlaybackVolumeChange);\n                events.on(player, 'repeatmodechange', onRepeatModeChange);\n                events.on(player, 'shufflequeuemodechange', onShuffleQueueModeChange);\n                events.on(player, 'playlistitemmove', onPlaylistItemMove);\n                events.on(player, 'playlistitemremove', onPlaylistItemRemove);\n                events.on(player, 'playlistitemadd', onPlaylistItemAdd);\n            } else if (player.isLocalPlayer) {\n                events.on(player, 'itemstarted', onPlaybackStartedFromSelfManagingPlayer);\n                events.on(player, 'itemstopped', onPlaybackStoppedFromSelfManagingPlayer);\n                events.on(player, 'timeupdate', onPlaybackTimeUpdate);\n                events.on(player, 'pause', onPlaybackPause);\n                events.on(player, 'unpause', onPlaybackUnpause);\n                events.on(player, 'volumechange', onPlaybackVolumeChange);\n                events.on(player, 'repeatmodechange', onRepeatModeChange);\n                events.on(player, 'shufflequeuemodechange', onShuffleQueueModeChange);\n                events.on(player, 'playlistitemmove', onPlaylistItemMove);\n                events.on(player, 'playlistitemremove', onPlaylistItemRemove);\n                events.on(player, 'playlistitemadd', onPlaylistItemAdd);\n            }\n\n            if (player.isLocalPlayer) {\n                bindToFullscreenChange(player);\n            }\n            bindStopped(player);\n        }\n\n        events.on(pluginManager, 'registered', function (e, plugin) {\n            if (plugin.type === 'mediaplayer') {\n                initMediaPlayer(plugin);\n            }\n        });\n\n        pluginManager.ofType('mediaplayer').map(initMediaPlayer);\n\n        function sendProgressUpdate(player, progressEventName, reportPlaylist) {\n            if (!player) {\n                throw new Error('player cannot be null');\n            }\n\n            const state = self.getPlayerState(player);\n\n            if (state.NowPlayingItem) {\n                const serverId = state.NowPlayingItem.ServerId;\n\n                const streamInfo = getPlayerData(player).streamInfo;\n\n                if (streamInfo && streamInfo.started && !streamInfo.ended) {\n                    reportPlayback(self, state, player, reportPlaylist, serverId, 'reportPlaybackProgress', progressEventName);\n                }\n\n                if (streamInfo && streamInfo.liveStreamId) {\n                    if (new Date().getTime() - (streamInfo.lastMediaInfoQuery || 0) >= 600000) {\n                        getLiveStreamMediaInfo(player, streamInfo, self.currentMediaSource(player), streamInfo.liveStreamId, serverId);\n                    }\n                }\n            }\n        }\n\n        function getLiveStreamMediaInfo(player, streamInfo, mediaSource, liveStreamId, serverId) {\n            console.debug('getLiveStreamMediaInfo');\n\n            streamInfo.lastMediaInfoQuery = new Date().getTime();\n\n            const apiClient = connectionManager.getApiClient(serverId);\n\n            if (!apiClient.isMinServerVersion('3.2.70.7')) {\n                return;\n            }\n\n            connectionManager.getApiClient(serverId).getLiveStreamMediaInfo(liveStreamId).then(function (info) {\n                mediaSource.MediaStreams = info.MediaStreams;\n                events.trigger(player, 'mediastreamschange');\n            }, function () {\n            });\n        }\n\n        self.onAppClose = function () {\n            const player = this._currentPlayer;\n\n            // Try to report playback stopped before the app closes\n            if (player && this.isPlaying(player)) {\n                this._playNextAfterEnded = false;\n                onPlaybackStopped.call(player);\n            }\n        };\n\n        self.playbackStartTime = function (player = this._currentPlayer) {\n            if (player && !enableLocalPlaylistManagement(player) && !player.isLocalPlayer) {\n                return player.playbackStartTime();\n            }\n\n            const streamInfo = getPlayerData(player).streamInfo;\n            return streamInfo ? streamInfo.playbackStartTimeTicks : null;\n        };\n\n        if (appHost.supports('remotecontrol')) {\n            import('serverNotifications').then(({ default: serverNotifications }) => {\n                events.on(serverNotifications, 'ServerShuttingDown', self.setDefaultPlayerActive.bind(self));\n                events.on(serverNotifications, 'ServerRestarting', self.setDefaultPlayerActive.bind(self));\n            });\n        }\n    }\n\n    getCurrentPlayer() {\n        return this._currentPlayer;\n    }\n\n    currentTime(player = this._currentPlayer) {\n        if (player && !enableLocalPlaylistManagement(player) && !player.isLocalPlayer) {\n            return player.currentTime();\n        }\n\n        return this.getCurrentTicks(player);\n    }\n\n    nextItem(player = this._currentPlayer) {\n        if (player && !enableLocalPlaylistManagement(player)) {\n            return player.nextItem();\n        }\n\n        const nextItem = this._playQueueManager.getNextItemInfo();\n\n        if (!nextItem || !nextItem.item) {\n            return Promise.reject();\n        }\n\n        const apiClient = connectionManager.getApiClient(nextItem.item.ServerId);\n        return apiClient.getItem(apiClient.getCurrentUserId(), nextItem.item.Id);\n    }\n\n    canQueue(item) {\n        if (item.Type === 'MusicAlbum' || item.Type === 'MusicArtist' || item.Type === 'MusicGenre') {\n            return this.canQueueMediaType('Audio');\n        }\n        return this.canQueueMediaType(item.MediaType);\n    }\n\n    canQueueMediaType(mediaType) {\n        if (this._currentPlayer) {\n            return this._currentPlayer.canPlayMediaType(mediaType);\n        }\n\n        return false;\n    }\n\n    isMuted(player = this._currentPlayer) {\n        if (player) {\n            return player.isMuted();\n        }\n\n        return false;\n    }\n\n    setMute(mute, player = this._currentPlayer) {\n        if (player) {\n            player.setMute(mute);\n        }\n    }\n\n    toggleMute(mute, player = this._currentPlayer) {\n        if (player) {\n            if (player.toggleMute) {\n                player.toggleMute();\n            } else {\n                player.setMute(!player.isMuted());\n            }\n        }\n    }\n\n    toggleDisplayMirroring() {\n        this.enableDisplayMirroring(!this.enableDisplayMirroring());\n    }\n\n    enableDisplayMirroring(enabled) {\n        if (enabled != null) {\n            const val = enabled ? '1' : '0';\n            appSettings.set('displaymirror', val);\n            return;\n        }\n\n        return (appSettings.get('displaymirror') || '') !== '0';\n    }\n\n    nextChapter(player = this._currentPlayer) {\n        const item = this.currentItem(player);\n\n        const ticks = this.getCurrentTicks(player);\n\n        const nextChapter = (item.Chapters || []).filter(function (i) {\n            return i.StartPositionTicks > ticks;\n        })[0];\n\n        if (nextChapter) {\n            this.seek(nextChapter.StartPositionTicks, player);\n        } else {\n            this.nextTrack(player);\n        }\n    }\n\n    previousChapter(player = this._currentPlayer) {\n        const item = this.currentItem(player);\n\n        let ticks = this.getCurrentTicks(player);\n\n        // Go back 10 seconds\n        ticks -= 100000000;\n\n        // If there's no previous track, then at least rewind to beginning\n        if (this.getCurrentPlaylistIndex(player) === 0) {\n            ticks = Math.max(ticks, 0);\n        }\n\n        const previousChapters = (item.Chapters || []).filter(function (i) {\n            return i.StartPositionTicks <= ticks;\n        });\n\n        if (previousChapters.length) {\n            this.seek(previousChapters[previousChapters.length - 1].StartPositionTicks, player);\n        } else {\n            this.previousTrack(player);\n        }\n    }\n\n    fastForward(player = this._currentPlayer) {\n        if (player.fastForward != null) {\n            player.fastForward(userSettings.skipForwardLength());\n            return;\n        }\n\n        // Go back 15 seconds\n        const offsetTicks = userSettings.skipForwardLength() * 10000;\n\n        this.seekRelative(offsetTicks, player);\n    }\n\n    rewind(player = this._currentPlayer) {\n        if (player.rewind != null) {\n            player.rewind(userSettings.skipBackLength());\n            return;\n        }\n\n        // Go back 15 seconds\n        const offsetTicks = 0 - (userSettings.skipBackLength() * 10000);\n\n        this.seekRelative(offsetTicks, player);\n    }\n\n    seekPercent(percent, player = this._currentPlayer) {\n        let ticks = this.duration(player) || 0;\n\n        percent /= 100;\n        ticks *= percent;\n        this.seek(parseInt(ticks), player);\n    }\n\n    seekMs(ms, player = this._currentPlayer) {\n        const ticks = ms * 10000;\n        this.seek(ticks, player);\n    }\n\n    playTrailers(item) {\n        const player = this._currentPlayer;\n\n        if (player && player.playTrailers) {\n            return player.playTrailers(item);\n        }\n\n        const apiClient = connectionManager.getApiClient(item.ServerId);\n\n        const instance = this;\n\n        if (item.LocalTrailerCount) {\n            return apiClient.getLocalTrailers(apiClient.getCurrentUserId(), item.Id).then(function (result) {\n                return instance.play({\n                    items: result\n                });\n            });\n        } else {\n            const remoteTrailers = item.RemoteTrailers || [];\n\n            if (!remoteTrailers.length) {\n                return Promise.reject();\n            }\n\n            return this.play({\n                items: remoteTrailers.map(function (t) {\n                    return {\n                        Name: t.Name || (item.Name + ' Trailer'),\n                        Url: t.Url,\n                        MediaType: 'Video',\n                        Type: 'Trailer',\n                        ServerId: apiClient.serverId()\n                    };\n                })\n            });\n        }\n    }\n\n    getSubtitleUrl(textStream, serverId) {\n        const apiClient = connectionManager.getApiClient(serverId);\n\n        return !textStream.IsExternalUrl ? apiClient.getUrl(textStream.DeliveryUrl) : textStream.DeliveryUrl;\n    }\n\n    stop(player) {\n        player = player || this._currentPlayer;\n        if (player) {\n            if (enableLocalPlaylistManagement(player)) {\n                this._playNextAfterEnded = false;\n            }\n\n            // TODO: remove second param\n            return player.stop(true, true);\n        }\n\n        return Promise.resolve();\n    }\n\n    getBufferedRanges(player = this._currentPlayer) {\n        if (player) {\n            if (player.getBufferedRanges) {\n                return player.getBufferedRanges();\n            }\n        }\n\n        return [];\n    }\n\n    playPause(player = this._currentPlayer) {\n        if (player) {\n            if (player.playPause) {\n                return player.playPause();\n            }\n\n            if (player.paused()) {\n                return this.unpause(player);\n            } else {\n                return this.pause(player);\n            }\n        }\n    }\n\n    paused(player = this._currentPlayer) {\n        if (player) {\n            return player.paused();\n        }\n    }\n\n    pause(player = this._currentPlayer) {\n        if (player) {\n            player.pause();\n        }\n    }\n\n    unpause(player = this._currentPlayer) {\n        if (player) {\n            player.unpause();\n        }\n    }\n\n    setPlaybackRate(value, player = this._currentPlayer) {\n        if (player && player.setPlaybackRate) {\n            player.setPlaybackRate(value);\n        }\n    }\n\n    getPlaybackRate(player = this._currentPlayer) {\n        if (player && player.getPlaybackRate) {\n            return player.getPlaybackRate();\n        }\n\n        return null;\n    }\n\n    instantMix(item, player = this._currentPlayer) {\n        if (player && player.instantMix) {\n            return player.instantMix(item);\n        }\n\n        const apiClient = connectionManager.getApiClient(item.ServerId);\n\n        const options = {};\n        options.UserId = apiClient.getCurrentUserId();\n        options.Limit = 200;\n\n        const instance = this;\n\n        apiClient.getInstantMixFromItem(item.Id, options).then(function (result) {\n            instance.play({\n                items: result.Items\n            });\n        });\n    }\n\n    shuffle(shuffleItem, player = this._currentPlayer) {\n        if (player && player.shuffle) {\n            return player.shuffle(shuffleItem);\n        }\n\n        return this.play({ items: [shuffleItem], shuffle: true });\n    }\n\n    audioTracks(player = this._currentPlayer) {\n        if (player.audioTracks) {\n            const result = player.audioTracks();\n            if (result) {\n                return result;\n            }\n        }\n\n        const mediaSource = this.currentMediaSource(player);\n\n        const mediaStreams = (mediaSource || {}).MediaStreams || [];\n        return mediaStreams.filter(function (s) {\n            return s.Type === 'Audio';\n        });\n    }\n\n    subtitleTracks(player = this._currentPlayer) {\n        if (player.subtitleTracks) {\n            const result = player.subtitleTracks();\n            if (result) {\n                return result;\n            }\n        }\n\n        const mediaSource = this.currentMediaSource(player);\n\n        const mediaStreams = (mediaSource || {}).MediaStreams || [];\n        return mediaStreams.filter(function (s) {\n            return s.Type === 'Subtitle';\n        });\n    }\n\n    getSupportedCommands(player) {\n        player = player || this._currentPlayer || { isLocalPlayer: true };\n\n        if (player.isLocalPlayer) {\n            const list = [\n                'GoHome',\n                'GoToSettings',\n                'VolumeUp',\n                'VolumeDown',\n                'Mute',\n                'Unmute',\n                'ToggleMute',\n                'SetVolume',\n                'SetAudioStreamIndex',\n                'SetSubtitleStreamIndex',\n                'SetMaxStreamingBitrate',\n                'DisplayContent',\n                'GoToSearch',\n                'DisplayMessage',\n                'SetRepeatMode',\n                'SetShuffleQueue',\n                'PlayMediaSource',\n                'PlayTrailers'\n            ];\n\n            if (appHost.supports('fullscreenchange')) {\n                list.push('ToggleFullscreen');\n            }\n\n            if (player.supports) {\n                if (player.supports('PictureInPicture')) {\n                    list.push('PictureInPicture');\n                }\n                if (player.supports('AirPlay')) {\n                    list.push('AirPlay');\n                }\n                if (player.supports('SetBrightness')) {\n                    list.push('SetBrightness');\n                }\n                if (player.supports('SetAspectRatio')) {\n                    list.push('SetAspectRatio');\n                }\n                if (player.supports('PlaybackRate')) {\n                    list.push('PlaybackRate');\n                }\n            }\n\n            return list;\n        }\n\n        const info = this.getPlayerInfo();\n        return info ? info.supportedCommands : [];\n    }\n\n    setRepeatMode(value, player = this._currentPlayer) {\n        if (player && !enableLocalPlaylistManagement(player)) {\n            return player.setRepeatMode(value);\n        }\n\n        this._playQueueManager.setRepeatMode(value);\n        events.trigger(player, 'repeatmodechange');\n    }\n\n    getRepeatMode(player = this._currentPlayer) {\n        if (player && !enableLocalPlaylistManagement(player)) {\n            return player.getRepeatMode();\n        }\n\n        return this._playQueueManager.getRepeatMode();\n    }\n\n    setQueueShuffleMode(value, player = this._currentPlayer) {\n        if (player && !enableLocalPlaylistManagement(player)) {\n            return player.setQueueShuffleMode(value);\n        }\n\n        this._playQueueManager.setShuffleMode(value);\n        events.trigger(player, 'shufflequeuemodechange');\n    }\n\n    getQueueShuffleMode(player = this._currentPlayer) {\n        if (player && !enableLocalPlaylistManagement(player)) {\n            return player.getQueueShuffleMode();\n        }\n\n        return this._playQueueManager.getShuffleMode();\n    }\n\n    toggleQueueShuffleMode(player = this._currentPlayer) {\n        let currentvalue;\n        if (player && !enableLocalPlaylistManagement(player)) {\n            currentvalue = player.getQueueShuffleMode();\n            switch (currentvalue) {\n                case 'Shuffle':\n                    player.setQueueShuffleMode('Sorted');\n                    break;\n                case 'Sorted':\n                    player.setQueueShuffleMode('Shuffle');\n                    break;\n                default:\n                    throw new TypeError('current value for shufflequeue is invalid');\n            }\n        } else {\n            this._playQueueManager.toggleShuffleMode();\n        }\n        events.trigger(player, 'shufflequeuemodechange');\n    }\n\n    clearQueue(clearCurrentItem = false, player = this._currentPlayer) {\n        if (player && !enableLocalPlaylistManagement(player)) {\n            return player.clearQueue(clearCurrentItem);\n        }\n\n        this._playQueueManager.clearPlaylist(clearCurrentItem);\n        events.trigger(player, 'playlistitemremove');\n    }\n\n    trySetActiveDeviceName(name) {\n        name = normalizeName(name);\n\n        const instance = this;\n        instance.getTargets().then(function (result) {\n            const target = result.filter(function (p) {\n                return normalizeName(p.name) === name;\n            })[0];\n\n            if (target) {\n                instance.trySetActivePlayer(target.playerName, target);\n            }\n        });\n    }\n\n    displayContent(options, player = this._currentPlayer) {\n        if (player && player.displayContent) {\n            player.displayContent(options);\n        }\n    }\n\n    beginPlayerUpdates(player) {\n        if (player.beginPlayerUpdates) {\n            player.beginPlayerUpdates();\n        }\n    }\n\n    endPlayerUpdates(player) {\n        if (player.endPlayerUpdates) {\n            player.endPlayerUpdates();\n        }\n    }\n\n    setDefaultPlayerActive() {\n        this.setActivePlayer('localplayer');\n    }\n\n    removeActivePlayer(name) {\n        const playerInfo = this.getPlayerInfo();\n        if (playerInfo) {\n            if (playerInfo.name === name) {\n                this.setDefaultPlayerActive();\n            }\n        }\n    }\n\n    removeActiveTarget(id) {\n        const playerInfo = this.getPlayerInfo();\n        if (playerInfo) {\n            if (playerInfo.id === id) {\n                this.setDefaultPlayerActive();\n            }\n        }\n    }\n\n    sendCommand(cmd, player) {\n        console.debug('MediaController received command: ' + cmd.Name);\n        switch (cmd.Name) {\n            case 'SetRepeatMode':\n                this.setRepeatMode(cmd.Arguments.RepeatMode, player);\n                break;\n            case 'SetShuffleQueue':\n                this.setQueueShuffleMode(cmd.Arguments.ShuffleMode, player);\n                break;\n            case 'VolumeUp':\n                this.volumeUp(player);\n                break;\n            case 'VolumeDown':\n                this.volumeDown(player);\n                break;\n            case 'Mute':\n                this.setMute(true, player);\n                break;\n            case 'Unmute':\n                this.setMute(false, player);\n                break;\n            case 'ToggleMute':\n                this.toggleMute(player);\n                break;\n            case 'SetVolume':\n                this.setVolume(cmd.Arguments.Volume, player);\n                break;\n            case 'SetAspectRatio':\n                this.setAspectRatio(cmd.Arguments.AspectRatio, player);\n                break;\n            case 'PlaybackRate':\n                this.setPlaybackRate(cmd.Arguments.PlaybackRate, player);\n                break;\n            case 'SetBrightness':\n                this.setBrightness(cmd.Arguments.Brightness, player);\n                break;\n            case 'SetAudioStreamIndex':\n                this.setAudioStreamIndex(parseInt(cmd.Arguments.Index), player);\n                break;\n            case 'SetSubtitleStreamIndex':\n                this.setSubtitleStreamIndex(parseInt(cmd.Arguments.Index), player);\n                break;\n            case 'SetMaxStreamingBitrate':\n                this.setMaxStreamingBitrate(parseInt(cmd.Arguments.Bitrate), player);\n                break;\n            case 'ToggleFullscreen':\n                this.toggleFullscreen(player);\n                break;\n            default:\n                if (player.sendCommand) {\n                    player.sendCommand(cmd);\n                }\n                break;\n        }\n    }\n}\n\nexport default new PlaybackManager();\n"]}