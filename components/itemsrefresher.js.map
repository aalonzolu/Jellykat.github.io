{"version":3,"sources":["components/itemsrefresher.js"],"names":["define","_exports","_playbackManager","_serverNotifications","_events","_interopRequireDefault","obj","__esModule","default","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","onUserDataChanged","e","apiClient","userData","eventsToMonitor","getEventsToMonitor","this","indexOf","notifyRefreshNeeded","instance","options","monitor","monitorEvents","split","onTimerCreated","data","onSeriesTimerCreated","onTimerCancelled","onSeriesTimerCancelled","onLibraryChanged","itemsAdded","ItemsAdded","itemsRemoved","ItemsRemoved","parentId","foldersAddedTo","FoldersAddedTo","foldersRemovedFrom","FoldersRemovedFrom","collectionFolders","CollectionFolders","onPlaybackStopped","stopInfo","state","NowPlayingItem","MediaType","addNotificationEvent","name","handler","owner","localHandler","bind","serverNotifications","events","on","removeNotificationEvent","off","clearRefreshInterval","isPausing","refreshInterval","clearInterval","refreshIntervalEndTime","resetRefreshInterval","intervalMs","refreshIntervalMs","setInterval","Date","getTime","onDataFetched","result","afterRefresh","value","_default","ItemsRefresher","_classCallCheck","Constructor","TypeError","playbackManager","_createClass","protoProps","staticProps","prototype","pause","paused","resume","remainingMs","needsRefresh","refresh","refreshItems","Promise","resolve","fetchData","then","isInForeground","timeout","refreshTimeout","clearTimeout","setTimeout","destroy"],"mappings":"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","file":"itemsrefresher.js","sourcesContent":["import playbackManager from 'playbackManager';\nimport serverNotifications from 'serverNotifications';\nimport events from 'events';\n\nfunction onUserDataChanged(e, apiClient, userData) {\n    const instance = this;\n\n    const eventsToMonitor = getEventsToMonitor(instance);\n\n    // TODO: Check user data change reason?\n    if (eventsToMonitor.indexOf('markfavorite') !== -1) {\n        instance.notifyRefreshNeeded();\n    } else if (eventsToMonitor.indexOf('markplayed') !== -1) {\n        instance.notifyRefreshNeeded();\n    }\n}\n\nfunction getEventsToMonitor(instance) {\n    const options = instance.options;\n    const monitor = options ? options.monitorEvents : null;\n    if (monitor) {\n        return monitor.split(',');\n    }\n\n    return [];\n}\n\nfunction onTimerCreated(e, apiClient, data) {\n    const instance = this;\n\n    if (getEventsToMonitor(instance).indexOf('timers') !== -1) {\n        instance.notifyRefreshNeeded();\n        return;\n    }\n}\n\nfunction onSeriesTimerCreated(e, apiClient, data) {\n    const instance = this;\n    if (getEventsToMonitor(instance).indexOf('seriestimers') !== -1) {\n        instance.notifyRefreshNeeded();\n        return;\n    }\n}\n\nfunction onTimerCancelled(e, apiClient, data) {\n    const instance = this;\n\n    if (getEventsToMonitor(instance).indexOf('timers') !== -1) {\n        instance.notifyRefreshNeeded();\n        return;\n    }\n}\n\nfunction onSeriesTimerCancelled(e, apiClient, data) {\n    const instance = this;\n    if (getEventsToMonitor(instance).indexOf('seriestimers') !== -1) {\n        instance.notifyRefreshNeeded();\n        return;\n    }\n}\n\nfunction onLibraryChanged(e, apiClient, data) {\n    const instance = this;\n    const eventsToMonitor = getEventsToMonitor(instance);\n    if (eventsToMonitor.indexOf('seriestimers') !== -1 || eventsToMonitor.indexOf('timers') !== -1) {\n        // yes this is an assumption\n        return;\n    }\n\n    const itemsAdded = data.ItemsAdded || [];\n    const itemsRemoved = data.ItemsRemoved || [];\n    if (!itemsAdded.length && !itemsRemoved.length) {\n        return;\n    }\n\n    const options = instance.options || {};\n    const parentId = options.parentId;\n    if (parentId) {\n        const foldersAddedTo = data.FoldersAddedTo || [];\n        const foldersRemovedFrom = data.FoldersRemovedFrom || [];\n        const collectionFolders = data.CollectionFolders || [];\n\n        if (foldersAddedTo.indexOf(parentId) === -1 && foldersRemovedFrom.indexOf(parentId) === -1 && collectionFolders.indexOf(parentId) === -1) {\n            return;\n        }\n    }\n\n    instance.notifyRefreshNeeded();\n}\n\nfunction onPlaybackStopped(e, stopInfo) {\n    const instance = this;\n\n    const state = stopInfo.state;\n\n    const eventsToMonitor = getEventsToMonitor(instance);\n    if (state.NowPlayingItem && state.NowPlayingItem.MediaType === 'Video') {\n        if (eventsToMonitor.indexOf('videoplayback') !== -1) {\n            instance.notifyRefreshNeeded(true);\n            return;\n        }\n    } else if (state.NowPlayingItem && state.NowPlayingItem.MediaType === 'Audio') {\n        if (eventsToMonitor.indexOf('audioplayback') !== -1) {\n            instance.notifyRefreshNeeded(true);\n            return;\n        }\n    }\n}\n\nfunction addNotificationEvent(instance, name, handler, owner) {\n    const localHandler = handler.bind(instance);\n    owner = owner || serverNotifications;\n    events.on(owner, name, localHandler);\n    instance['event_' + name] = localHandler;\n}\n\nfunction removeNotificationEvent(instance, name, owner) {\n    const handler = instance['event_' + name];\n    if (handler) {\n        owner = owner || serverNotifications;\n        events.off(owner, name, handler);\n        instance['event_' + name] = null;\n    }\n}\n\nclass ItemsRefresher {\n    constructor(options) {\n        this.options = options || {};\n\n        addNotificationEvent(this, 'UserDataChanged', onUserDataChanged);\n        addNotificationEvent(this, 'TimerCreated', onTimerCreated);\n        addNotificationEvent(this, 'SeriesTimerCreated', onSeriesTimerCreated);\n        addNotificationEvent(this, 'TimerCancelled', onTimerCancelled);\n        addNotificationEvent(this, 'SeriesTimerCancelled', onSeriesTimerCancelled);\n        addNotificationEvent(this, 'LibraryChanged', onLibraryChanged);\n        addNotificationEvent(this, 'playbackstop', onPlaybackStopped, playbackManager);\n    }\n\n    pause() {\n        clearRefreshInterval(this, true);\n\n        this.paused = true;\n    }\n\n    resume(options) {\n        this.paused = false;\n\n        const refreshIntervalEndTime = this.refreshIntervalEndTime;\n        if (refreshIntervalEndTime) {\n            const remainingMs = refreshIntervalEndTime - new Date().getTime();\n            if (remainingMs > 0 && !this.needsRefresh) {\n                resetRefreshInterval(this, remainingMs);\n            } else {\n                this.needsRefresh = true;\n                this.refreshIntervalEndTime = null;\n            }\n        }\n\n        if (this.needsRefresh || (options && options.refresh)) {\n            return this.refreshItems();\n        }\n\n        return Promise.resolve();\n    }\n\n    refreshItems() {\n        if (!this.fetchData) {\n            return Promise.resolve();\n        }\n\n        if (this.paused) {\n            this.needsRefresh = true;\n            return Promise.resolve();\n        }\n\n        this.needsRefresh = false;\n\n        return this.fetchData().then(onDataFetched.bind(this));\n    }\n\n    notifyRefreshNeeded(isInForeground) {\n        if (this.paused) {\n            this.needsRefresh = true;\n            return;\n        }\n\n        const timeout = this.refreshTimeout;\n        if (timeout) {\n            clearTimeout(timeout);\n        }\n\n        if (isInForeground === true) {\n            this.refreshItems();\n        } else {\n            this.refreshTimeout = setTimeout(this.refreshItems.bind(this), 10000);\n        }\n    }\n\n    destroy() {\n        clearRefreshInterval(this);\n\n        removeNotificationEvent(this, 'UserDataChanged');\n        removeNotificationEvent(this, 'TimerCreated');\n        removeNotificationEvent(this, 'SeriesTimerCreated');\n        removeNotificationEvent(this, 'TimerCancelled');\n        removeNotificationEvent(this, 'SeriesTimerCancelled');\n        removeNotificationEvent(this, 'LibraryChanged');\n        removeNotificationEvent(this, 'playbackstop', playbackManager);\n\n        this.fetchData = null;\n        this.options = null;\n    }\n}\n\nfunction clearRefreshInterval(instance, isPausing) {\n    if (instance.refreshInterval) {\n        clearInterval(instance.refreshInterval);\n        instance.refreshInterval = null;\n\n        if (!isPausing) {\n            instance.refreshIntervalEndTime = null;\n        }\n    }\n}\n\nfunction resetRefreshInterval(instance, intervalMs) {\n    clearRefreshInterval(instance);\n\n    if (!intervalMs) {\n        const options = instance.options;\n        if (options) {\n            intervalMs = options.refreshIntervalMs;\n        }\n    }\n\n    if (intervalMs) {\n        instance.refreshInterval = setInterval(instance.notifyRefreshNeeded.bind(instance), intervalMs);\n        instance.refreshIntervalEndTime = new Date().getTime() + intervalMs;\n    }\n}\n\nfunction onDataFetched(result) {\n    resetRefreshInterval(this);\n\n    if (this.afterRefresh) {\n        this.afterRefresh(result);\n    }\n}\n\nexport default ItemsRefresher;\n"]}