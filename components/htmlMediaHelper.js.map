{"version":3,"sources":["components/htmlMediaHelper.js"],"names":["define","_exports","_appSettings","_browser","_events","_interopRequireDefault","obj","__esModule","default","recoverDecodingErrorDate","recoverSwapAudioCodecDate","handleHlsJsMediaError","instance","reject","hlsPlayer","_hlsPlayer","now","Date","window","performance","console","debug","recoverMediaError","swapAudioCodec","error","onErrorInternal","type","destroyCustomTrack","_mediaElement","events","trigger","isValidDuration","duration","isNaN","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","setCurrentTimeIfNeeded","element","seconds","Math","abs","currentTime","onSuccessfulPlay","elem","onErrorFn","addEventListener","playWithPromise","promise","play","then","catch","e","errorName","name","toLowerCase","Promise","resolve","err","destroyCastPlayer","player","_castPlayer","unload","destroyHlsPlayer","destroy","destroyFlvPlayer","_flvPlayer","detachMediaElement","Object","defineProperty","value","getSavedVolume","appSettings","get","saveVolume","set","getCrossOriginValue","mediaSource","IsRemote","enableHlsJsPlayer","runTimeTicks","mediaType","MediaSource","browser","iOS","tizen","web0s","canPlayNativeHls","media","document","createElement","canPlayType","replace","android","edge","seekOnPlaybackStart","ticks","onMediaReady","onMediaChange","concat","map","removeEventListener","applySrc","src","options","Windows","IsLocal","Storage","StorageFile","getFileFromPathAsync","url","file","playlist","Media","Playback","MediaPlaybackList","source1","Core","createFromStorageFile","startTime","playerStartPositionTicks","items","append","MediaPlaybackItem","URL","createObjectURL","oneTimeOnly","bindEventsToHlsPlayer","hls","on","Hls","Events","MANIFEST_PARSED","ERROR","event","data","details","fatal","ErrorTypes","NETWORK_ERROR","response","code","startLoad","MEDIA_ERROR","currentReject","onEndedInternal","innerHTML","removeAttribute","stopInfo","_currentSrc","_currentTime","_currentPlayOptions","getBufferedRanges","offset","ranges","seekable","buffered","currentPlayOptions","transcodingOffsetTicks","i","length","start","end","push"],"mappings":"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","file":"htmlMediaHelper.js","sourcesContent":["/* eslint-disable indent */\n\nimport appSettings from 'appSettings' ;\nimport browser from 'browser';\nimport events from 'events';\n\n    export function getSavedVolume() {\n        return appSettings.get('volume') || 1;\n    }\n\n    export function saveVolume(value) {\n        if (value) {\n            appSettings.set('volume', value);\n        }\n    }\n\n    export function getCrossOriginValue(mediaSource) {\n        if (mediaSource.IsRemote) {\n            return null;\n        }\n\n        return 'anonymous';\n    }\n\n    function canPlayNativeHls() {\n        var media = document.createElement('video');\n\n        if (media.canPlayType('application/x-mpegURL').replace(/no/, '') ||\n            media.canPlayType('application/vnd.apple.mpegURL').replace(/no/, '')) {\n            return true;\n        }\n\n        return false;\n    }\n\n    export function enableHlsJsPlayer(runTimeTicks, mediaType) {\n        if (window.MediaSource == null) {\n            return false;\n        }\n\n        // hls.js is only in beta. needs more testing.\n        if (browser.iOS) {\n            return false;\n        }\n\n        // The native players on these devices support seeking live streams, no need to use hls.js here\n        if (browser.tizen || browser.web0s) {\n            return false;\n        }\n\n        if (canPlayNativeHls()) {\n            // Having trouble with chrome's native support and transcoded music\n            if (browser.android && mediaType === 'Audio') {\n                return true;\n            }\n\n            if (browser.edge && mediaType === 'Video') {\n                //return true;\n            }\n\n            // simple playback should use the native support\n            if (runTimeTicks) {\n                //if (!browser.edge) {\n                return false;\n                //}\n            }\n\n            //return false;\n        }\n\n        return true;\n    }\n\n    var recoverDecodingErrorDate;\n    var recoverSwapAudioCodecDate;\n    export function handleHlsJsMediaError(instance, reject) {\n        var hlsPlayer = instance._hlsPlayer;\n\n        if (!hlsPlayer) {\n            return;\n        }\n\n        var now = Date.now();\n\n        if (window.performance && window.performance.now) {\n            now = performance.now(); // eslint-disable-line compat/compat\n        }\n\n        if (!recoverDecodingErrorDate || (now - recoverDecodingErrorDate) > 3000) {\n            recoverDecodingErrorDate = now;\n            console.debug('try to recover media Error ...');\n            hlsPlayer.recoverMediaError();\n        } else {\n            if (!recoverSwapAudioCodecDate || (now - recoverSwapAudioCodecDate) > 3000) {\n                recoverSwapAudioCodecDate = now;\n                console.debug('try to swap Audio Codec and recover media Error ...');\n                hlsPlayer.swapAudioCodec();\n                hlsPlayer.recoverMediaError();\n            } else {\n                console.error('cannot recover, last media error recovery failed ...');\n\n                if (reject) {\n                    reject();\n                } else {\n                    onErrorInternal(instance, 'mediadecodeerror');\n                }\n            }\n        }\n    }\n\n    export function onErrorInternal(instance, type) {\n        // Needed for video\n        if (instance.destroyCustomTrack) {\n            instance.destroyCustomTrack(instance._mediaElement);\n        }\n\n        events.trigger(instance, 'error', [\n            {\n                type: type\n            }\n        ]);\n    }\n\n    export function isValidDuration(duration) {\n        if (duration && !isNaN(duration) && duration !== Number.POSITIVE_INFINITY && duration !== Number.NEGATIVE_INFINITY) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function setCurrentTimeIfNeeded(element, seconds) {\n        if (Math.abs(element.currentTime || 0, seconds) <= 1) {\n            element.currentTime = seconds;\n        }\n    }\n\n    export function seekOnPlaybackStart(instance, element, ticks, onMediaReady) {\n        var seconds = (ticks || 0) / 10000000;\n\n        if (seconds) {\n            // Appending #t=xxx to the query string doesn't seem to work with HLS\n            // For plain video files, not all browsers support it either\n\n            if (element.duration >= seconds) {\n                // media is ready, seek immediately\n                setCurrentTimeIfNeeded(element, seconds);\n                if (onMediaReady) onMediaReady();\n            } else {\n                // update video player position when media is ready to be sought\n                var events = ['durationchange', 'loadeddata', 'play', 'loadedmetadata'];\n                var onMediaChange = function(e) {\n                    if (element.currentTime === 0 && element.duration >= seconds) {\n                        // seek only when video position is exactly zero,\n                        // as this is true only if video hasn't started yet or\n                        // user rewound to the very beginning\n                        // (but rewinding cannot happen as the first event with media of non-empty duration)\n                        console.debug(`seeking to ${seconds} on ${e.type} event`);\n                        setCurrentTimeIfNeeded(element, seconds);\n                        events.map(function(name) {\n                            element.removeEventListener(name, onMediaChange);\n                        });\n                        if (onMediaReady) onMediaReady();\n                    }\n                };\n                events.map(function (name) {\n                    return element.addEventListener(name, onMediaChange);\n                });\n            }\n        }\n    }\n\n    export function applySrc(elem, src, options) {\n        if (window.Windows && options.mediaSource && options.mediaSource.IsLocal) {\n            return Windows.Storage.StorageFile.getFileFromPathAsync(options.url).then(function (file) {\n                var playlist = new Windows.Media.Playback.MediaPlaybackList();\n\n                var source1 = Windows.Media.Core.MediaSource.createFromStorageFile(file);\n                var startTime = (options.playerStartPositionTicks || 0) / 10000;\n                playlist.items.append(new Windows.Media.Playback.MediaPlaybackItem(source1, startTime));\n                elem.src = URL.createObjectURL(playlist, { oneTimeOnly: true });\n                return Promise.resolve();\n            });\n        } else {\n            elem.src = src;\n        }\n\n        return Promise.resolve();\n    }\n\n    function onSuccessfulPlay(elem, onErrorFn) {\n        elem.addEventListener('error', onErrorFn);\n    }\n\n    export function playWithPromise(elem, onErrorFn) {\n        try {\n            var promise = elem.play();\n            if (promise && promise.then) {\n                // Chrome now returns a promise\n                return promise.catch(function (e) {\n                    var errorName = (e.name || '').toLowerCase();\n                    // safari uses aborterror\n                    if (errorName === 'notallowederror' ||\n                        errorName === 'aborterror') {\n                        // swallow this error because the user can still click the play button on the video element\n                        onSuccessfulPlay(elem, onErrorFn);\n                        return Promise.resolve();\n                    }\n                    return Promise.reject();\n                });\n            } else {\n                onSuccessfulPlay(elem, onErrorFn);\n                return Promise.resolve();\n            }\n        } catch (err) {\n            console.error('error calling video.play: ' + err);\n            return Promise.reject();\n        }\n    }\n\n    export function destroyCastPlayer(instance) {\n        var player = instance._castPlayer;\n        if (player) {\n            try {\n                player.unload();\n            } catch (err) {\n                console.error(err);\n            }\n\n            instance._castPlayer = null;\n        }\n    }\n\n    export function destroyHlsPlayer(instance) {\n        var player = instance._hlsPlayer;\n        if (player) {\n            try {\n                player.destroy();\n            } catch (err) {\n                console.error(err);\n            }\n\n            instance._hlsPlayer = null;\n        }\n    }\n\n    export function destroyFlvPlayer(instance) {\n        var player = instance._flvPlayer;\n        if (player) {\n            try {\n                player.unload();\n                player.detachMediaElement();\n                player.destroy();\n            } catch (err) {\n                console.error(err);\n            }\n\n            instance._flvPlayer = null;\n        }\n    }\n\n    export function bindEventsToHlsPlayer(instance, hls, elem, onErrorFn, resolve, reject) {\n        hls.on(Hls.Events.MANIFEST_PARSED, function () {\n            playWithPromise(elem, onErrorFn).then(resolve, function () {\n                if (reject) {\n                    reject();\n                    reject = null;\n                }\n            });\n        });\n\n        hls.on(Hls.Events.ERROR, function (event, data) {\n            console.error('HLS Error: Type: ' + data.type + ' Details: ' + (data.details || '') + ' Fatal: ' + (data.fatal || false));\n\n            switch (data.type) {\n                case Hls.ErrorTypes.NETWORK_ERROR:\n                    // try to recover network error\n                    if (data.response && data.response.code && data.response.code >= 400) {\n                        console.debug('hls.js response error code: ' + data.response.code);\n\n                        // Trigger failure differently depending on whether this is prior to start of playback, or after\n                        hls.destroy();\n\n                        if (reject) {\n                            reject('servererror');\n                            reject = null;\n                        } else {\n                            onErrorInternal(instance, 'servererror');\n                        }\n\n                        return;\n                    }\n\n                    break;\n                default:\n                    break;\n            }\n\n            if (data.fatal) {\n                switch (data.type) {\n                    case Hls.ErrorTypes.NETWORK_ERROR:\n\n                        if (data.response && data.response.code === 0) {\n                            // This could be a CORS error related to access control response headers\n\n                            console.debug('hls.js response error code: ' + data.response.code);\n\n                            // Trigger failure differently depending on whether this is prior to start of playback, or after\n                            hls.destroy();\n\n                            if (reject) {\n                                reject('network');\n                                reject = null;\n                            } else {\n                                onErrorInternal(instance, 'network');\n                            }\n                        } else {\n                            console.debug('fatal network error encountered, try to recover');\n                            hls.startLoad();\n                        }\n\n                        break;\n                    case Hls.ErrorTypes.MEDIA_ERROR:\n                        console.debug('fatal media error encountered, try to recover');\n                        var currentReject = reject;\n                        reject = null;\n                        handleHlsJsMediaError(instance, currentReject);\n                        break;\n                    default:\n\n                        console.debug('Cannot recover from hls error - destroy and trigger error');\n                        // cannot recover\n                        // Trigger failure differently depending on whether this is prior to start of playback, or after\n                        hls.destroy();\n\n                        if (reject) {\n                            reject();\n                            reject = null;\n                        } else {\n                            onErrorInternal(instance, 'mediadecodeerror');\n                        }\n                        break;\n                }\n            }\n        });\n    }\n\n    export function onEndedInternal(instance, elem, onErrorFn) {\n        elem.removeEventListener('error', onErrorFn);\n\n        elem.src = '';\n        elem.innerHTML = '';\n        elem.removeAttribute('src');\n\n        destroyHlsPlayer(instance);\n        destroyFlvPlayer(instance);\n        destroyCastPlayer(instance);\n\n        var stopInfo = {\n            src: instance._currentSrc\n        };\n\n        events.trigger(instance, 'stopped', [stopInfo]);\n\n        instance._currentTime = null;\n        instance._currentSrc = null;\n        instance._currentPlayOptions = null;\n    }\n\n    export function getBufferedRanges(instance, elem) {\n        var ranges = [];\n        var seekable = elem.buffered || [];\n\n        var offset;\n        var currentPlayOptions = instance._currentPlayOptions;\n        if (currentPlayOptions) {\n            offset = currentPlayOptions.transcodingOffsetTicks;\n        }\n\n        offset = offset || 0;\n\n        for (var i = 0, length = seekable.length; i < length; i++) {\n            var start = seekable.start(i);\n            var end = seekable.end(i);\n\n            if (!isValidDuration(start)) {\n                start = 0;\n            }\n            if (!isValidDuration(end)) {\n                end = 0;\n                continue;\n            }\n\n            ranges.push({\n                start: (start * 10000000) + offset,\n                end: (end * 10000000) + offset\n            });\n        }\n\n        return ranges;\n    }\n\n/* eslint-enable indent */\n"]}