{"version":3,"sources":["components/focusManager.js"],"names":["define","_exports","_dom","_scrollManager","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","scopes","autoFocus","view","defaultToFirst","findAutoFocusElement","element","querySelector","getFocusableElements","focus","preventScroll","scrollManager","isEnabled","err","console","error","focusableTagNames","focusableContainerTagNames","focusableQuery","map","t","join","isFocusable","elem","indexOf","tagName","classList","contains","normalizeFocusable","originalElement","focusableParent","parent","parentNode","isCurrentlyFocusableInternal","offsetParent","getDefaultScope","document","body","limit","excludeClass","elems","querySelectorAll","focusableElements","i","length","push","isFocusContainer","direction","getOffset","box","getBoundingClientRect","top","left","width","height","right","bottom","nav","activeElement","container","getFocusContainer","nearestElement","focusableContainer","dom","parentWithClass","rect","point1x","parseFloat","point1y","point2x","point2y","sourceMidX","sourceMidY","focusable","minDistance","Infinity","curr","elementRect","distX","distY","x","y","x2","y2","intersectX","intersects","intersectY","midX","midY","Math","abs","min","max","dist","sqrt","nearestElementFocusableParent","intersectsInternal","a1","a2","b1","b2","_default","moveLeft","sourceElement","options","moveRight","moveUp","moveDown","sendText","text","isCurrentlyFocusable","disabled","getAttribute","type","pushScope","popScope","focusFirst","focusableSelector","focusLast","slice","call","reverse","moveFocus","offset","list","currentIndex","newIndex","newElem"],"mappings":"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","file":"focusManager.js","sourcesContent":["/* eslint-disable indent */\n\nimport dom from 'dom';\nimport scrollManager from 'scrollManager';\n\n    var scopes = [];\n    function pushScope(elem) {\n        scopes.push(elem);\n    }\n\n    function popScope(elem) {\n        if (scopes.length) {\n            scopes.length -= 1;\n        }\n    }\n\n    function autoFocus(view, defaultToFirst, findAutoFocusElement) {\n        var element;\n        if (findAutoFocusElement !== false) {\n            element = view.querySelector('*[autofocus]');\n            if (element) {\n                focus(element);\n                return element;\n            }\n        }\n\n        if (defaultToFirst !== false) {\n            element = getFocusableElements(view, 1, 'noautofocus')[0];\n\n            if (element) {\n                focus(element);\n                return element;\n            }\n        }\n\n        return null;\n    }\n\n    function focus(element) {\n        try {\n            element.focus({\n                preventScroll: scrollManager.isEnabled()\n            });\n        } catch (err) {\n            console.error('Error in focusManager.autoFocus: ' + err);\n        }\n    }\n\n    var focusableTagNames = ['INPUT', 'TEXTAREA', 'SELECT', 'BUTTON', 'A'];\n    var focusableContainerTagNames = ['BODY', 'DIALOG'];\n    var focusableQuery = focusableTagNames.map(function (t) {\n        if (t === 'INPUT') {\n            t += ':not([type=\"range\"]):not([type=\"file\"])';\n        }\n        return t + ':not([tabindex=\"-1\"]):not(:disabled)';\n    }).join(',') + ',.focusable';\n\n    function isFocusable(elem) {\n        if (focusableTagNames.indexOf(elem.tagName) !== -1) {\n            return true;\n        }\n\n        if (elem.classList && elem.classList.contains('focusable')) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function normalizeFocusable(elem, originalElement) {\n        if (elem) {\n            var tagName = elem.tagName;\n            if (!tagName || tagName === 'HTML' || tagName === 'BODY') {\n                elem = originalElement;\n            }\n        }\n\n        return elem;\n    }\n\n    function focusableParent(elem) {\n        var originalElement = elem;\n\n        while (!isFocusable(elem)) {\n            var parent = elem.parentNode;\n\n            if (!parent) {\n                return normalizeFocusable(elem, originalElement);\n            }\n\n            elem = parent;\n        }\n\n        return normalizeFocusable(elem, originalElement);\n    }\n\n    // Determines if a focusable element can be focused at a given point in time\n    function isCurrentlyFocusableInternal(elem) {\n        // http://stackoverflow.com/questions/19669786/check-if-element-is-visible-in-dom\n        if (elem.offsetParent === null) {\n            return false;\n        }\n\n        return true;\n    }\n\n    // Determines if a focusable element can be focused at a given point in time\n    function isCurrentlyFocusable(elem) {\n        if (elem.disabled) {\n            return false;\n        }\n\n        if (elem.getAttribute('tabindex') === '-1') {\n            return false;\n        }\n\n        if (elem.tagName === 'INPUT') {\n            var type = elem.type;\n            if (type === 'range') {\n                return false;\n            }\n            if (type === 'file') {\n                return false;\n            }\n        }\n\n        return isCurrentlyFocusableInternal(elem);\n    }\n\n    function getDefaultScope() {\n        return scopes[0] || document.body;\n    }\n\n    function getFocusableElements(parent, limit, excludeClass) {\n        var elems = (parent || getDefaultScope()).querySelectorAll(focusableQuery);\n        var focusableElements = [];\n\n        for (var i = 0, length = elems.length; i < length; i++) {\n            var elem = elems[i];\n\n            if (excludeClass && elem.classList.contains(excludeClass)) {\n                continue;\n            }\n\n            if (isCurrentlyFocusableInternal(elem)) {\n                focusableElements.push(elem);\n\n                if (limit && focusableElements.length >= limit) {\n                    break;\n                }\n            }\n        }\n\n        return focusableElements;\n    }\n\n    function isFocusContainer(elem, direction) {\n        if (focusableContainerTagNames.indexOf(elem.tagName) !== -1) {\n            return true;\n        }\n\n        var classList = elem.classList;\n\n        if (classList.contains('focuscontainer')) {\n            return true;\n        }\n\n        if (direction === 0) {\n            if (classList.contains('focuscontainer-x')) {\n                return true;\n            }\n            if (classList.contains('focuscontainer-left')) {\n                return true;\n            }\n        } else if (direction === 1) {\n            if (classList.contains('focuscontainer-x')) {\n                return true;\n            }\n            if (classList.contains('focuscontainer-right')) {\n                return true;\n            }\n        } else if (direction === 2) {\n            if (classList.contains('focuscontainer-y')) {\n                return true;\n            }\n        } else if (direction === 3) {\n            if (classList.contains('focuscontainer-y')) {\n                return true;\n            }\n            if (classList.contains('focuscontainer-down')) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function getFocusContainer(elem, direction) {\n        while (!isFocusContainer(elem, direction)) {\n            elem = elem.parentNode;\n\n            if (!elem) {\n                return getDefaultScope();\n            }\n        }\n\n        return elem;\n    }\n\n    function getOffset(elem) {\n        var box;\n\n        // Support: BlackBerry 5, iOS 3 (original iPhone)\n        // If we don't have gBCR, just use 0,0 rather than error\n        if (elem.getBoundingClientRect) {\n            box = elem.getBoundingClientRect();\n        } else {\n            box = {\n                top: 0,\n                left: 0,\n                width: 0,\n                height: 0\n            };\n        }\n\n        if (box.right === null) {\n            // Create a new object because some browsers will throw an error when trying to set data onto the Rect object\n            var newBox = {\n                top: box.top,\n                left: box.left,\n                width: box.width,\n                height: box.height\n            };\n\n            box = newBox;\n\n            box.right = box.left + box.width;\n            box.bottom = box.top + box.height;\n        }\n\n        return box;\n    }\n\n    function nav(activeElement, direction, container, focusableElements) {\n        activeElement = activeElement || document.activeElement;\n\n        if (activeElement) {\n            activeElement = focusableParent(activeElement);\n        }\n\n        container = container || (activeElement ? getFocusContainer(activeElement, direction) : getDefaultScope());\n\n        if (!activeElement) {\n            autoFocus(container, true, false);\n            return;\n        }\n\n        var focusableContainer = dom.parentWithClass(activeElement, 'focusable');\n\n        var rect = getOffset(activeElement);\n\n        // Get elements and work out x/y points\n        var point1x = parseFloat(rect.left) || 0;\n        var point1y = parseFloat(rect.top) || 0;\n        var point2x = parseFloat(point1x + rect.width - 1) || point1x;\n        var point2y = parseFloat(point1y + rect.height - 1) || point1y;\n\n        var sourceMidX = rect.left + (rect.width / 2);\n        var sourceMidY = rect.top + (rect.height / 2);\n\n        var focusable = focusableElements || container.querySelectorAll(focusableQuery);\n\n        var maxDistance = Infinity;\n        var minDistance = maxDistance;\n        var nearestElement;\n\n        for (var i = 0, length = focusable.length; i < length; i++) {\n            var curr = focusable[i];\n\n            if (curr === activeElement) {\n                continue;\n            }\n            // Don't refocus into the same container\n            if (curr === focusableContainer) {\n                continue;\n            }\n\n            var elementRect = getOffset(curr);\n\n            // not currently visible\n            if (!elementRect.width && !elementRect.height) {\n                continue;\n            }\n\n            switch (direction) {\n                case 0:\n                    // left\n                    if (elementRect.left >= rect.left) {\n                        continue;\n                    }\n                    if (elementRect.right === rect.right) {\n                        continue;\n                    }\n                    break;\n                case 1:\n                    // right\n                    if (elementRect.right <= rect.right) {\n                        continue;\n                    }\n                    if (elementRect.left === rect.left) {\n                        continue;\n                    }\n                    break;\n                case 2:\n                    // up\n                    if (elementRect.top >= rect.top) {\n                        continue;\n                    }\n                    if (elementRect.bottom >= rect.bottom) {\n                        continue;\n                    }\n                    break;\n                case 3:\n                    // down\n                    if (elementRect.bottom <= rect.bottom) {\n                        continue;\n                    }\n                    if (elementRect.top <= rect.top) {\n                        continue;\n                    }\n                    break;\n                default:\n                    break;\n            }\n\n            var x = elementRect.left;\n            var y = elementRect.top;\n            var x2 = x + elementRect.width - 1;\n            var y2 = y + elementRect.height - 1;\n\n            var intersectX = intersects(point1x, point2x, x, x2);\n            var intersectY = intersects(point1y, point2y, y, y2);\n\n            var midX = elementRect.left + (elementRect.width / 2);\n            var midY = elementRect.top + (elementRect.height / 2);\n\n            var distX;\n            var distY;\n\n            switch (direction) {\n                case 0:\n                    // left\n                    distX = Math.abs(point1x - Math.min(point1x, x2));\n                    distY = intersectY ? 0 : Math.abs(sourceMidY - midY);\n                    break;\n                case 1:\n                    // right\n                    distX = Math.abs(point2x - Math.max(point2x, x));\n                    distY = intersectY ? 0 : Math.abs(sourceMidY - midY);\n                    break;\n                case 2:\n                    // up\n                    distY = Math.abs(point1y - Math.min(point1y, y2));\n                    distX = intersectX ? 0 : Math.abs(sourceMidX - midX);\n                    break;\n                case 3:\n                    // down\n                    distY = Math.abs(point2y - Math.max(point2y, y));\n                    distX = intersectX ? 0 : Math.abs(sourceMidX - midX);\n                    break;\n                default:\n                    break;\n            }\n\n            var dist = Math.sqrt(distX * distX + distY * distY);\n\n            if (dist < minDistance) {\n                nearestElement = curr;\n                minDistance = dist;\n            }\n        }\n\n        if (nearestElement) {\n            // See if there's a focusable container, and if so, send the focus command to that\n            if (activeElement) {\n                var nearestElementFocusableParent = dom.parentWithClass(nearestElement, 'focusable');\n                if (nearestElementFocusableParent && nearestElementFocusableParent !== nearestElement) {\n                    if (focusableContainer !== nearestElementFocusableParent) {\n                        nearestElement = nearestElementFocusableParent;\n                    }\n                }\n            }\n            focus(nearestElement);\n        }\n    }\n\n    function intersectsInternal(a1, a2, b1, b2) {\n        return (b1 >= a1 && b1 <= a2) || (b2 >= a1 && b2 <= a2);\n    }\n\n    function intersects(a1, a2, b1, b2) {\n        return intersectsInternal(a1, a2, b1, b2) || intersectsInternal(b1, b2, a1, a2);\n    }\n\n    function sendText(text) {\n        var elem = document.activeElement;\n\n        elem.value = text;\n    }\n\n    function focusFirst(container, focusableSelector) {\n        var elems = container.querySelectorAll(focusableSelector);\n\n        for (var i = 0, length = elems.length; i < length; i++) {\n            var elem = elems[i];\n\n            if (isCurrentlyFocusableInternal(elem)) {\n                focus(elem);\n                break;\n            }\n        }\n    }\n\n    function focusLast(container, focusableSelector) {\n        var elems = [].slice.call(container.querySelectorAll(focusableSelector), 0).reverse();\n\n        for (var i = 0, length = elems.length; i < length; i++) {\n            var elem = elems[i];\n\n            if (isCurrentlyFocusableInternal(elem)) {\n                focus(elem);\n                break;\n            }\n        }\n    }\n\n    function moveFocus(sourceElement, container, focusableSelector, offset) {\n        var elems = container.querySelectorAll(focusableSelector);\n        var list = [];\n        var i;\n        var length;\n        var elem;\n\n        for (i = 0, length = elems.length; i < length; i++) {\n            elem = elems[i];\n\n            if (isCurrentlyFocusableInternal(elem)) {\n                list.push(elem);\n            }\n        }\n\n        var currentIndex = -1;\n\n        for (i = 0, length = list.length; i < length; i++) {\n            elem = list[i];\n\n            if (sourceElement === elem || elem.contains(sourceElement)) {\n                currentIndex = i;\n                break;\n            }\n        }\n\n        if (currentIndex === -1) {\n            return;\n        }\n\n        var newIndex = currentIndex + offset;\n        newIndex = Math.max(0, newIndex);\n        newIndex = Math.min(newIndex, list.length - 1);\n\n        var newElem = list[newIndex];\n        if (newElem) {\n            focus(newElem);\n        }\n    }\n\n/* eslint-enable indent */\n\nexport default {\n    autoFocus: autoFocus,\n    focus: focus,\n    focusableParent: focusableParent,\n    getFocusableElements: getFocusableElements,\n    moveLeft: function (sourceElement, options) {\n        var container = options ? options.container : null;\n        var focusableElements = options ? options.focusableElements : null;\n        nav(sourceElement, 0, container, focusableElements);\n    },\n    moveRight: function (sourceElement, options) {\n        var container = options ? options.container : null;\n        var focusableElements = options ? options.focusableElements : null;\n        nav(sourceElement, 1, container, focusableElements);\n    },\n    moveUp: function (sourceElement, options) {\n        var container = options ? options.container : null;\n        var focusableElements = options ? options.focusableElements : null;\n        nav(sourceElement, 2, container, focusableElements);\n    },\n    moveDown: function (sourceElement, options) {\n        var container = options ? options.container : null;\n        var focusableElements = options ? options.focusableElements : null;\n        nav(sourceElement, 3, container, focusableElements);\n    },\n    sendText: sendText,\n    isCurrentlyFocusable: isCurrentlyFocusable,\n    pushScope: pushScope,\n    popScope: popScope,\n    focusFirst: focusFirst,\n    focusLast: focusLast,\n    moveFocus: moveFocus\n};\n"]}