{"version":3,"sources":["libraries/scroller.js"],"names":["define","_exports","_browser","_layoutManager","_dom","_focusManager","_ResizeObserver","_scrollStyles","_interopRequireDefault","obj","__esModule","default","_typeof","Symbol","iterator","constructor","prototype","disableOneEvent","event","preventDefault","stopPropagation","this","removeEventListener","type","within","number","min","max","Object","defineProperty","value","dragMouseEvents","dragTouchEvents","wheelEvent","document","implementation","hasFeature","interactiveElements","scrollerFactory","frame","options","o","assign","slidee","horizontal","mouseWheel","scrollBy","dragSource","mouseDragging","touchDragging","dragThreshold","intervactive","speed","isSmoothScrollSupported","documentElement","style","allowNativeScroll","enableNativeScroll","browser","firefox","layoutManager","tv","allowNativeSmoothScroll","requireAnimation","animate","supportsCssAnimation","web0s","self","slideeElement","sibling","n","elem","matched","nextSibling","nodeType","push","firstChild","_pos","start","center","end","cur","dest","transform","scrollSource","dragSourceElement","dragging","released","scrolling","last","delta","resetTime","initialized","nativeScrollElement","lastAnimate","requiresReflow","frameSize","slideeSize","ensureSizeInfo","offsetWidth","offsetHeight","scrollWidth","Math","load","isInit","pos","slideTo","setStyleProperty","name","resetTransition","edge","transition","getBoundingClientRect","top","left","dragInitSlidee","isTouch","init","isInteractive","element","indexOf","tagName","parentNode","target","which","source","touch","pointer","touches","initX","pageX","initY","pageY","initPos","Date","time","path","locked","pathToLock","forEach","eventName","dom","addEventListener","dragHandler","passive","pathX","pathY","sqrt","pow","dragEnd","undefined","abs","round","setTimeout","scrollHandler","normalizeWheelDelta","curDelta","deltaX","deltaY","deltaMode","slideBy","scrollLeft","scrollTop","reload","getScrollEventName","getScrollSlider","getScrollFrame","newPos","immediate","fullItemPos","now","getTime","autoImmediate","skipSlideToWhenVisible","isVisible","renderAnimateWithTransform","fromPosition","toPosition","immediateSpeed","dispatchScrollEventIfNeeded","dispatchScrollEvent","dispatchEvent","CustomEvent","bubbles","cancelable","from","nativeScrollTo","container","scroll","behavior","scrollTo","getPos","item","slideeOffset","itemOffset","offset","size","width","height","centerOffset","currentStart","currentEnd","console","debug","getCenterPosition","destroy","frameResizeObserver","disconnect","resetScroll","onFrameClick","capture","contentRect","onResize","entries","entry","newRect","e","focusableParent","focusManager","activeElement","focus","getScrollPosition","getScrollSize","scrollHeight","overflow","classList","add","desktop","hideScrollbar","forceHideScrollbars","initFrameResizeObserver","ResizeObserver","observe","to","location","String","toString","call","match","toLowerCase","itemPos","toStart","toEnd","toCenter","create","instance","Promise","resolve","_default"],"mappings":"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","file":"scroller.js","sourcesContent":["/* Cleaning this file properly is not neecessary, since it's an outdated library\n * and will be replaced soon by a Vue component.\n */\n\nimport browser from 'browser';\nimport layoutManager from 'layoutManager';\nimport dom from 'dom';\nimport focusManager from 'focusManager';\nimport ResizeObserver from 'ResizeObserver';\nimport 'scrollStyles';\n\n/**\n* Return type of the value.\n*\n* @param  {Mixed} value\n*\n* @return {String}\n*/\nfunction type(value) {\n    if (value == null) {\n        return String(value);\n    }\n\n    if (typeof value === 'object' || typeof value === 'function') {\n        return Object.prototype.toString.call(value).match(/\\s([a-z]+)/i)[1].toLowerCase() || 'object';\n    }\n\n    return typeof value;\n}\n\n/**\n * Disables an event it was triggered on and unbinds itself.\n *\n * @param  {Event} event\n *\n * @return {Void}\n */\nfunction disableOneEvent(event) {\n    /*jshint validthis:true */\n    event.preventDefault();\n    event.stopPropagation();\n    this.removeEventListener(event.type, disableOneEvent);\n}\n\n/**\n * Make sure that number is within the limits.\n *\n * @param {Number} number\n * @param {Number} min\n * @param {Number} max\n *\n * @return {Number}\n */\nfunction within(number, min, max) {\n    return number < min ? min : number > max ? max : number;\n}\n\n// Other global values\nvar dragMouseEvents = ['mousemove', 'mouseup'];\nvar dragTouchEvents = ['touchmove', 'touchend'];\nvar wheelEvent = (document.implementation.hasFeature('Event.wheel', '3.0') ? 'wheel' : 'mousewheel');\nvar interactiveElements = ['INPUT', 'SELECT', 'TEXTAREA'];\n\nvar scrollerFactory = function (frame, options) {\n    // Extend options\n    var o = Object.assign({}, {\n        slidee: null, // Selector, DOM element, or jQuery object with DOM element representing SLIDEE.\n        horizontal: false, // Switch to horizontal mode.\n\n        // Scrolling\n        mouseWheel: true,\n        scrollBy: 0, // Pixels or items to move per one mouse scroll. 0 to disable scrolling\n\n        // Dragging\n        dragSource: null, // Selector or DOM element for catching dragging events. Default is FRAME.\n        mouseDragging: 1, // Enable navigation by dragging the SLIDEE with mouse cursor.\n        touchDragging: 1, // Enable navigation by dragging the SLIDEE with touch events.\n        dragThreshold: 3, // Distance in pixels before Sly recognizes dragging.\n        intervactive: null, // Selector for special interactive elements.\n\n        // Mixed options\n        speed: 0 // Animations speed in milliseconds. 0 to disable animations.\n\n    }, options);\n\n    var isSmoothScrollSupported = 'scrollBehavior' in document.documentElement.style;\n\n    // native scroll is a must with touch input\n    // also use native scroll when scrolling vertically in desktop mode - excluding horizontal because the mouse wheel support is choppy at the moment\n    // in cases with firefox, if the smooth scroll api is supported then use that because their implementation is very good\n    if (options.allowNativeScroll === false) {\n        options.enableNativeScroll = false;\n    } else if (isSmoothScrollSupported && ((browser.firefox && !layoutManager.tv) || options.allowNativeSmoothScroll)) {\n        // native smooth scroll\n        options.enableNativeScroll = true;\n    } else if (options.requireAnimation && (browser.animate || browser.supportsCssAnimation())) {\n        // transform is the only way to guarantee animation\n        options.enableNativeScroll = false;\n    } else if (!layoutManager.tv || !browser.animate) {\n        options.enableNativeScroll = true;\n    }\n\n    // Need this for the magic wheel. With the animated scroll the magic wheel will run off of the screen\n    if (browser.web0s) {\n        options.enableNativeScroll = true;\n    }\n\n    // Private variables\n    var self = this;\n    self.options = o;\n\n    // Frame\n    var slideeElement = o.slidee ? o.slidee : sibling(frame.firstChild)[0];\n    self._pos = {\n        start: 0,\n        center: 0,\n        end: 0,\n        cur: 0,\n        dest: 0\n    };\n\n    var transform = !options.enableNativeScroll;\n\n    // Miscellaneous\n    var scrollSource = frame;\n    var dragSourceElement = o.dragSource ? o.dragSource : frame;\n    var dragging = {\n        released: 1\n    };\n    var scrolling = {\n        last: 0,\n        delta: 0,\n        resetTime: 200\n    };\n\n    // Expose properties\n    self.initialized = 0;\n    self.slidee = slideeElement;\n    self.options = o;\n    self.dragging = dragging;\n\n    var nativeScrollElement = frame;\n\n    function sibling(n, elem) {\n        var matched = [];\n\n        for (; n; n = n.nextSibling) {\n            if (n.nodeType === 1 && n !== elem) {\n                matched.push(n);\n            }\n        }\n        return matched;\n    }\n\n    var requiresReflow = true;\n\n    var frameSize = 0;\n    var slideeSize = 0;\n    function ensureSizeInfo() {\n        if (requiresReflow) {\n            requiresReflow = false;\n\n            // Reset global variables\n            frameSize = o.horizontal ? (frame).offsetWidth : (frame).offsetHeight;\n\n            slideeSize = o.scrollWidth || Math.max(slideeElement[o.horizontal ? 'offsetWidth' : 'offsetHeight'], slideeElement[o.horizontal ? 'scrollWidth' : 'scrollHeight']);\n\n            // Set position limits & relativess\n            self._pos.end = Math.max(slideeSize - frameSize, 0);\n        }\n    }\n\n    /**\n     * Loading function.\n     *\n     * Populate arrays, set sizes, bind events, ...\n     *\n     * @param {Boolean} [isInit] Whether load is called from within self.init().\n     * @return {Void}\n     */\n    function load(isInit) {\n        requiresReflow = true;\n\n        if (!isInit) {\n            ensureSizeInfo();\n\n            // Fix possible overflowing\n            var pos = self._pos;\n            self.slideTo(within(pos.dest, pos.start, pos.end));\n        }\n    }\n\n    function initFrameResizeObserver() {\n        var observerOptions = {};\n\n        self.frameResizeObserver = new ResizeObserver(onResize, observerOptions);\n\n        self.frameResizeObserver.observe(frame);\n    }\n\n    self.reload = function () {\n        load();\n    };\n\n    self.getScrollEventName = function () {\n        return transform ? 'scrollanimate' : 'scroll';\n    };\n\n    self.getScrollSlider = function () {\n        return slideeElement;\n    };\n\n    self.getScrollFrame = function () {\n        return frame;\n    };\n\n    function nativeScrollTo(container, pos, immediate) {\n        if (container.scroll) {\n            if (o.horizontal) {\n                container.scroll({\n                    left: pos,\n                    behavior: immediate ? 'instant' : 'smooth'\n                });\n            } else {\n                container.scroll({\n                    top: pos,\n                    behavior: immediate ? 'instant' : 'smooth'\n                });\n            }\n        } else if (!immediate && container.scrollTo) {\n            if (o.horizontal) {\n                container.scrollTo(Math.round(pos), 0);\n            } else {\n                container.scrollTo(0, Math.round(pos));\n            }\n        } else {\n            if (o.horizontal) {\n                container.scrollLeft = Math.round(pos);\n            } else {\n                container.scrollTop = Math.round(pos);\n            }\n        }\n    }\n\n    var lastAnimate;\n\n    /**\n         * Animate to a position.\n         *\n         * @param {Int}  newPos    New position.\n         * @param {Bool} immediate Reposition immediately without an animation.\n         *\n         * @return {Void}\n         */\n    self.slideTo = function (newPos, immediate, fullItemPos) {\n        ensureSizeInfo();\n        var pos = self._pos;\n\n        newPos = within(newPos, pos.start, pos.end);\n\n        if (!transform) {\n            nativeScrollTo(nativeScrollElement, newPos, immediate);\n            return;\n        }\n\n        // Update the animation object\n        var from = pos.cur;\n        immediate = immediate || dragging.init || !o.speed;\n\n        var now = new Date().getTime();\n\n        if (o.autoImmediate) {\n            if (!immediate && (now - (lastAnimate || 0)) <= 50) {\n                immediate = true;\n            }\n        }\n\n        if (!immediate && o.skipSlideToWhenVisible && fullItemPos && fullItemPos.isVisible) {\n            return;\n        }\n\n        // Start animation rendering\n        // NOTE the dependency was modified here to fix a scrollbutton issue\n        pos.dest = newPos;\n        renderAnimateWithTransform(from, newPos, immediate);\n        lastAnimate = now;\n    };\n\n    function setStyleProperty(elem, name, value, speed, resetTransition) {\n        var style = elem.style;\n\n        if (resetTransition || browser.edge) {\n            style.transition = 'none';\n            void elem.offsetWidth;\n        }\n\n        style.transition = 'transform ' + speed + 'ms ease-out';\n        style[name] = value;\n    }\n\n    function dispatchScrollEventIfNeeded() {\n        if (o.dispatchScrollEvent) {\n            frame.dispatchEvent(new CustomEvent(self.getScrollEventName(), {\n                bubbles: true,\n                cancelable: false\n            }));\n        }\n    }\n\n    function renderAnimateWithTransform(fromPosition, toPosition, immediate) {\n        var speed = o.speed;\n\n        if (immediate) {\n            speed = o.immediateSpeed || 50;\n        }\n\n        if (o.horizontal) {\n            setStyleProperty(slideeElement, 'transform', 'translateX(' + (-Math.round(toPosition)) + 'px)', speed);\n        } else {\n            setStyleProperty(slideeElement, 'transform', 'translateY(' + (-Math.round(toPosition)) + 'px)', speed);\n        }\n        self._pos.cur = toPosition;\n\n        dispatchScrollEventIfNeeded();\n    }\n\n    function getBoundingClientRect(elem) {\n        // Support: BlackBerry 5, iOS 3 (original iPhone)\n        // If we don't have gBCR, just use 0,0 rather than error\n        if (elem.getBoundingClientRect) {\n            return elem.getBoundingClientRect();\n        } else {\n            return { top: 0, left: 0 };\n        }\n    }\n\n    /**\n     * Returns the position object.\n     *\n     * @param {Mixed} item\n     *\n     * @return {Object}\n     */\n    self.getPos = function (item) {\n        var scrollElement = transform ? slideeElement : nativeScrollElement;\n        var slideeOffset = getBoundingClientRect(scrollElement);\n        var itemOffset = getBoundingClientRect(item);\n\n        var offset = o.horizontal ? itemOffset.left - slideeOffset.left : itemOffset.top - slideeOffset.top;\n\n        var size = o.horizontal ? itemOffset.width : itemOffset.height;\n        if (!size && size !== 0) {\n            size = item[o.horizontal ? 'offsetWidth' : 'offsetHeight'];\n        }\n\n        var centerOffset = o.centerOffset || 0;\n\n        if (!transform) {\n            centerOffset = 0;\n            if (o.horizontal) {\n                offset += nativeScrollElement.scrollLeft;\n            } else {\n                offset += nativeScrollElement.scrollTop;\n            }\n        }\n\n        ensureSizeInfo();\n\n        var currentStart = self._pos.cur;\n        var currentEnd = currentStart + frameSize;\n\n        console.debug('offset:' + offset + ' currentStart:' + currentStart + ' currentEnd:' + currentEnd);\n        var isVisible = offset >= currentStart && (offset + size) <= currentEnd;\n\n        return {\n            start: offset,\n            center: offset + centerOffset - (frameSize / 2) + (size / 2),\n            end: offset - frameSize + size,\n            size: size,\n            isVisible: isVisible\n        };\n    };\n\n    self.getCenterPosition = function (item) {\n        ensureSizeInfo();\n\n        var pos = self.getPos(item);\n        return within(pos.center, pos.start, pos.end);\n    };\n\n    function dragInitSlidee(event) {\n        var isTouch = event.type === 'touchstart';\n\n        // Ignore when already in progress, or interactive element in non-touch navivagion\n        if (dragging.init || !isTouch && isInteractive(event.target)) {\n            return;\n        }\n\n        // SLIDEE dragging conditions\n        if (!(isTouch ? o.touchDragging : o.mouseDragging && event.which < 2)) {\n            return;\n        }\n\n        if (!isTouch) {\n            // prevents native image dragging in Firefox\n            event.preventDefault();\n        }\n\n        // Reset dragging object\n        dragging.released = 0;\n\n        // Properties used in dragHandler\n        dragging.init = 0;\n        dragging.source = event.target;\n        dragging.touch = isTouch;\n        var pointer = isTouch ? event.touches[0] : event;\n        dragging.initX = pointer.pageX;\n        dragging.initY = pointer.pageY;\n        dragging.initPos = self._pos.cur;\n        dragging.start = +new Date();\n        dragging.time = 0;\n        dragging.path = 0;\n        dragging.delta = 0;\n        dragging.locked = 0;\n        dragging.pathToLock = isTouch ? 30 : 10;\n\n        // Bind dragging events\n        if (transform) {\n            if (isTouch) {\n                dragTouchEvents.forEach(function (eventName) {\n                    dom.addEventListener(document, eventName, dragHandler, {\n                        passive: true\n                    });\n                });\n            } else {\n                dragMouseEvents.forEach(function (eventName) {\n                    dom.addEventListener(document, eventName, dragHandler, {\n                        passive: true\n                    });\n                });\n            }\n        }\n    }\n\n    /**\n     * Handler for dragging scrollbar handle or SLIDEE.\n     *\n     * @param  {Event} event\n     *\n     * @return {Void}\n     */\n    function dragHandler(event) {\n        dragging.released = event.type === 'mouseup' || event.type === 'touchend';\n        var pointer = dragging.touch ? event[dragging.released ? 'changedTouches' : 'touches'][0] : event;\n        dragging.pathX = pointer.pageX - dragging.initX;\n        dragging.pathY = pointer.pageY - dragging.initY;\n        dragging.path = Math.sqrt(Math.pow(dragging.pathX, 2) + Math.pow(dragging.pathY, 2));\n        dragging.delta = o.horizontal ? dragging.pathX : dragging.pathY;\n\n        if (!dragging.released && dragging.path < 1) {\n            return;\n        }\n\n        // We haven't decided whether this is a drag or not...\n        if (!dragging.init) {\n            // If the drag path was very short, maybe it's not a drag?\n            if (dragging.path < o.dragThreshold) {\n                // If the pointer was released, the path will not become longer and it's\n                // definitely not a drag. If not released yet, decide on next iteration\n                return dragging.released ? dragEnd() : undefined;\n            } else {\n                // If dragging path is sufficiently long we can confidently start a drag\n                // if drag is in different direction than scroll, ignore it\n                if (o.horizontal ? Math.abs(dragging.pathX) > Math.abs(dragging.pathY) : Math.abs(dragging.pathX) < Math.abs(dragging.pathY)) {\n                    dragging.init = 1;\n                } else {\n                    return dragEnd();\n                }\n            }\n        }\n\n        //event.preventDefault();\n\n        // Disable click on a source element, as it is unwelcome when dragging\n        if (!dragging.locked && dragging.path > dragging.pathToLock) {\n            dragging.locked = 1;\n            dragging.source.addEventListener('click', disableOneEvent);\n        }\n\n        // Cancel dragging on release\n        if (dragging.released) {\n            dragEnd();\n        }\n\n        self.slideTo(Math.round(dragging.initPos - dragging.delta));\n    }\n\n    /**\n     * Stops dragging and cleans up after it.\n     *\n     * @return {Void}\n     */\n    function dragEnd() {\n        dragging.released = true;\n\n        dragTouchEvents.forEach(function (eventName) {\n            dom.removeEventListener(document, eventName, dragHandler, {\n                passive: true\n            });\n        });\n\n        dragMouseEvents.forEach(function (eventName) {\n            dom.removeEventListener(document, eventName, dragHandler, {\n                passive: true\n            });\n        });\n\n        // Make sure that disableOneEvent is not active in next tick.\n        setTimeout(function () {\n            dragging.source.removeEventListener('click', disableOneEvent);\n        });\n\n        dragging.init = 0;\n    }\n\n    /**\n     * Check whether element is interactive.\n     *\n     * @return {Boolean}\n     */\n    function isInteractive(element) {\n        while (element) {\n            if (interactiveElements.indexOf(element.tagName) !== -1) {\n                return true;\n            }\n\n            element = element.parentNode;\n        }\n        return false;\n    }\n\n    /**\n     * Mouse wheel delta normalization.\n     *\n     * @param  {Event} event\n     *\n     * @return {Int}\n     */\n    function normalizeWheelDelta(event) {\n        // JELLYFIN MOD: Only use deltaX for horizontal scroll and remove IE8 support\n        scrolling.curDelta = o.horizontal ? event.deltaX : event.deltaY;\n        // END JELLYFIN MOD\n\n        if (transform) {\n            scrolling.curDelta /= event.deltaMode === 1 ? 3 : 100;\n        }\n        return scrolling.curDelta;\n    }\n\n    /**\n     * Mouse scrolling handler.\n     *\n     * @param  {Event} event\n     *\n     * @return {Void}\n     */\n    function scrollHandler(event) {\n        ensureSizeInfo();\n        var pos = self._pos;\n        // Ignore if there is no scrolling to be done\n        if (!o.scrollBy || pos.start === pos.end) {\n            return;\n        }\n        var delta = normalizeWheelDelta(event);\n\n        if (transform) {\n            // Trap scrolling only when necessary and/or requested\n            if (delta > 0 && pos.dest < pos.end || delta < 0 && pos.dest > pos.start) {\n                //stopDefault(event, 1);\n            }\n\n            self.slideBy(o.scrollBy * delta);\n        } else {\n            if (isSmoothScrollSupported) {\n                delta *= 12;\n            }\n\n            if (o.horizontal) {\n                nativeScrollElement.scrollLeft += delta;\n            } else {\n                nativeScrollElement.scrollTop += delta;\n            }\n        }\n    }\n\n    /**\n     * Destroys instance and everything it created.\n     *\n     * @return {Void}\n     */\n    self.destroy = function () {\n        if (self.frameResizeObserver) {\n            self.frameResizeObserver.disconnect();\n            self.frameResizeObserver = null;\n        }\n\n        // Reset native FRAME element scroll\n        dom.removeEventListener(frame, 'scroll', resetScroll, {\n            passive: true\n        });\n\n        dom.removeEventListener(scrollSource, wheelEvent, scrollHandler, {\n            passive: true\n        });\n\n        dom.removeEventListener(dragSourceElement, 'touchstart', dragInitSlidee, {\n            passive: true\n        });\n\n        dom.removeEventListener(frame, 'click', onFrameClick, {\n            passive: true,\n            capture: true\n        });\n\n        dom.removeEventListener(dragSourceElement, 'mousedown', dragInitSlidee, {\n            //passive: true\n        });\n\n        // Reset initialized status and return the instance\n        self.initialized = 0;\n        return self;\n    };\n\n    var contentRect = {};\n\n    function onResize(entries) {\n        var entry = entries[0];\n\n        if (entry) {\n            var newRect = entry.contentRect;\n\n            // handle element being hidden\n            if (newRect.width === 0 || newRect.height === 0) {\n                return;\n            }\n\n            if (newRect.width !== contentRect.width || newRect.height !== contentRect.height) {\n                contentRect = newRect;\n\n                load(false);\n            }\n        }\n    }\n\n    function resetScroll() {\n        if (o.horizontal) {\n            this.scrollLeft = 0;\n        } else {\n            this.scrollTop = 0;\n        }\n    }\n\n    function onFrameClick(e) {\n        if (e.which === 1) {\n            var focusableParent = focusManager.focusableParent(e.target);\n            if (focusableParent && focusableParent !== document.activeElement) {\n                focusableParent.focus();\n            }\n        }\n    }\n\n    self.getScrollPosition = function () {\n        if (transform) {\n            return self._pos.cur;\n        }\n\n        if (o.horizontal) {\n            return nativeScrollElement.scrollLeft;\n        } else {\n            return nativeScrollElement.scrollTop;\n        }\n    };\n\n    self.getScrollSize = function () {\n        if (transform) {\n            return slideeSize;\n        }\n\n        if (o.horizontal) {\n            return nativeScrollElement.scrollWidth;\n        } else {\n            return nativeScrollElement.scrollHeight;\n        }\n    };\n\n    /**\n     * Initialize.\n     *\n     * @return {Object}\n     */\n    self.init = function () {\n        if (self.initialized) {\n            return;\n        }\n\n        if (!transform) {\n            if (o.horizontal) {\n                if (layoutManager.desktop && !o.hideScrollbar) {\n                    nativeScrollElement.classList.add('scrollX');\n                } else {\n                    nativeScrollElement.classList.add('scrollX');\n                    nativeScrollElement.classList.add('hiddenScrollX');\n\n                    if (layoutManager.tv && o.allowNativeSmoothScroll !== false) {\n                        nativeScrollElement.classList.add('smoothScrollX');\n                    }\n                }\n\n                if (o.forceHideScrollbars) {\n                    nativeScrollElement.classList.add('hiddenScrollX-forced');\n                }\n            } else {\n                if (layoutManager.desktop && !o.hideScrollbar) {\n                    nativeScrollElement.classList.add('scrollY');\n                } else {\n                    nativeScrollElement.classList.add('scrollY');\n                    nativeScrollElement.classList.add('hiddenScrollY');\n\n                    if (layoutManager.tv && o.allowNativeSmoothScroll !== false) {\n                        nativeScrollElement.classList.add('smoothScrollY');\n                    }\n                }\n\n                if (o.forceHideScrollbars) {\n                    nativeScrollElement.classList.add('hiddenScrollY-forced');\n                }\n            }\n        } else {\n            frame.style.overflow = 'hidden';\n            slideeElement.style['will-change'] = 'transform';\n            slideeElement.style.transition = 'transform ' + o.speed + 'ms ease-out';\n\n            if (o.horizontal) {\n                slideeElement.classList.add('animatedScrollX');\n            } else {\n                slideeElement.classList.add('animatedScrollY');\n            }\n        }\n\n        if (transform || layoutManager.tv) {\n            // This can prevent others from being able to listen to mouse events\n            dom.addEventListener(dragSourceElement, 'mousedown', dragInitSlidee, {\n                //passive: true\n            });\n        }\n\n        initFrameResizeObserver();\n\n        if (transform) {\n            dom.addEventListener(dragSourceElement, 'touchstart', dragInitSlidee, {\n                passive: true\n            });\n\n            if (!o.horizontal) {\n                dom.addEventListener(frame, 'scroll', resetScroll, {\n                    passive: true\n                });\n            }\n\n            if (o.mouseWheel) {\n                // Scrolling navigation\n                dom.addEventListener(scrollSource, wheelEvent, scrollHandler, {\n                    passive: true\n                });\n            }\n        } else if (o.horizontal) {\n            // Don't bind to mouse events with vertical scroll since the mouse wheel can handle this natively\n\n            if (o.mouseWheel) {\n                // Scrolling navigation\n                dom.addEventListener(scrollSource, wheelEvent, scrollHandler, {\n                    passive: true\n                });\n            }\n        }\n\n        dom.addEventListener(frame, 'click', onFrameClick, {\n            passive: true,\n            capture: true\n        });\n\n        // Mark instance as initialized\n        self.initialized = 1;\n\n        // Load\n        load(true);\n\n        // Return instance\n        return self;\n    };\n};\n\n/**\n * Slide SLIDEE by amount of pixels.\n *\n * @param {Int}  delta     Pixels/Items. Positive means forward, negative means backward.\n * @param {Bool} immediate Reposition immediately without an animation.\n *\n * @return {Void}\n */\nscrollerFactory.prototype.slideBy = function (delta, immediate) {\n    if (!delta) {\n        return;\n    }\n    this.slideTo(this._pos.dest + delta, immediate);\n};\n\n/**\n * Core method for handling `toLocation` methods.\n *\n * @param  {String} location\n * @param  {Mixed}  item\n * @param  {Bool}   immediate\n *\n * @return {Void}\n */\nscrollerFactory.prototype.to = function (location, item, immediate) {\n    // Optional arguments logic\n    if (type(item) === 'boolean') {\n        immediate = item;\n        item = undefined;\n    }\n\n    if (item === undefined) {\n        this.slideTo(this._pos[location], immediate);\n    } else {\n        var itemPos = this.getPos(item);\n\n        if (itemPos) {\n            this.slideTo(itemPos[location], immediate, itemPos);\n        }\n    }\n};\n\n/**\n * Animate element or the whole SLIDEE to the start of the frame.\n *\n * @param {Mixed} item      Item DOM element, or index starting at 0. Omitting will animate SLIDEE.\n * @param {Bool}  immediate Reposition immediately without an animation.\n *\n * @return {Void}\n */\nscrollerFactory.prototype.toStart = function (item, immediate) {\n    this.to('start', item, immediate);\n};\n\n/**\n * Animate element or the whole SLIDEE to the end of the frame.\n *\n * @param {Mixed} item      Item DOM element, or index starting at 0. Omitting will animate SLIDEE.\n * @param {Bool}  immediate Reposition immediately without an animation.\n *\n * @return {Void}\n */\nscrollerFactory.prototype.toEnd = function (item, immediate) {\n    this.to('end', item, immediate);\n};\n\n/**\n * Animate element or the whole SLIDEE to the center of the frame.\n *\n * @param {Mixed} item      Item DOM element, or index starting at 0. Omitting will animate SLIDEE.\n * @param {Bool}  immediate Reposition immediately without an animation.\n *\n * @return {Void}\n */\nscrollerFactory.prototype.toCenter = function (item, immediate) {\n    this.to('center', item, immediate);\n};\n\nscrollerFactory.create = function (frame, options) {\n    var instance = new scrollerFactory(frame, options);\n    return Promise.resolve(instance);\n};\n\nexport default scrollerFactory;\n"]}