{"version":3,"sources":["elements/emby-slider/emby-slider.js"],"names":["define","_browser","_dom","_layoutManager","_keyboardnavigation","_embySlider","_webcomponents","_embyInput","_interopRequireDefault","obj","__esModule","default","EmbySliderPrototype","Object","create","HTMLInputElement","prototype","supportsValueSetOverride","getOwnPropertyDescriptor","defineProperty","descriptor","configurable","mapClientToFraction","range","clientX","rect","sliderBubbleTrack","getBoundingClientRect","fraction","left","width","valueRange","max","min","step","Math","round","mapFractionToValue","value","parseFloat","updateValues","isValueSet","this","keyboardDragging","touched","cancelAnimationFrame","updateValuesFrame","requestAnimationFrame","backgroundLower","style","updateBubble","bubble","bubbleText","bubbleTrackRect","bubbleRect","bubblePos","getBubbleHtml","getBubbleText","toLocaleString","innerHTML","attachedCallback","getAttribute","setAttribute","classList","add","browser","edge","layoutManager","mobile","tv","topContainer","dom","parentWithClass","label","ownerDocument","createElement","htmlFor","id","insertBefore","firstChild","containerElement","parentNode","insertAdjacentHTML","htmlToInsert","querySelector","backgroundUpper","sliderBubble","hasHideClass","contains","addEventListener","e","dragging","dataset","sliderKeepProgress","call","mapValueToFraction","remove","passive","window","PointerEvent","iOS","targetTouches","length","dispatchEvent","Event","bubbles","cancelable","preventDefault","capture","setTimeout","bind","startInterval","interval","clearInterval","setInterval","keyboardDraggingTimer","startKeyboardDragging","elem","clearTimeout","finishKeyboardDragging","undefined","event","stepKeyboard","delta","onKeyDown","keyboardnavigation","getKeyName","keyboardStepDown","stopPropagation","keyboardStepUp","setRange","startPercent","endPercent","widthPercent","enableKeyboardDragging","keyboardDraggingEnabled","setKeyboardSteps","stepDown","stepUp","setBufferedRanges","ranges","runtime","position","mapRangesFromRuntimeToPercent","map","r","start","end","setIsClear","isClear","detachedCallback","document","registerElement","extends"],"mappings":"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","file":"emby-slider.js","sourcesContent":["import browser from 'browser';\nimport dom from 'dom';\nimport layoutManager from 'layoutManager';\nimport keyboardnavigation from 'keyboardnavigation';\nimport 'css!./emby-slider';\nimport 'webcomponents';\nimport 'emby-input';\n\n/* eslint-disable indent */\n\n    const EmbySliderPrototype = Object.create(HTMLInputElement.prototype);\n\n    let supportsValueSetOverride = false;\n\n    if (Object.getOwnPropertyDescriptor && Object.defineProperty) {\n        const descriptor = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, 'value');\n        // descriptor returning null in webos\n        if (descriptor && descriptor.configurable) {\n            supportsValueSetOverride = true;\n        }\n    }\n\n    /**\n     * Returns slider fraction corresponding to client position.\n     *\n     * @param {Object} range slider itself\n     * @param {number} clientX client X-coordinate\n     * @return {number} slider fraction\n     */\n    function mapClientToFraction(range, clientX) {\n        const rect = range.sliderBubbleTrack.getBoundingClientRect();\n\n        let fraction = (clientX - rect.left) / rect.width;\n\n        // Snap to step\n        const valueRange = range.max - range.min;\n        if (range.step !== 'any' && valueRange !== 0) {\n            const step = (range.step || 1) / valueRange;\n            fraction = Math.round(fraction / step) * step;\n        }\n\n        return Math.min(Math.max(fraction, 0), 1);\n    }\n\n    /**\n     * Returns slider value corresponding to slider fraction.\n     *\n     * @param {Object} range slider itself\n     * @param {number} fraction slider fraction\n     * @return {number} slider value\n     */\n    function mapFractionToValue(range, fraction) {\n        let value = (range.max - range.min) * fraction;\n\n        // Snap to step\n        if (range.step !== 'any') {\n            var step = range.step || 1;\n            value = Math.round(value / step) * step;\n        }\n\n        value += parseFloat(range.min);\n\n        return Math.min(Math.max(value, range.min), range.max);\n    }\n\n    /**\n     * Returns slider fraction corresponding to slider value.\n     *\n     * @param {Object} range slider itself\n     * @param {number} value slider value (snapped to step)\n     * @return {number} slider fraction\n     */\n    function mapValueToFraction(range, value) {\n        const valueRange = range.max - range.min;\n        const fraction = valueRange !== 0 ? (value - range.min) / valueRange : 0;\n        return Math.min(Math.max(fraction, 0), 1);\n    }\n\n    /**\n     * Updates progress bar.\n     *\n     * @param {boolean} [isValueSet] update by 'valueset' event or by timer\n     */\n    function updateValues(isValueSet) {\n        // Do not update values by 'valueset' in case of soft-implemented dragging\n        if (!!isValueSet && (!!this.keyboardDragging || !!this.touched)) {\n            return;\n        }\n\n        const range = this;\n        const value = range.value;\n\n        // put this on a callback. Doing it within the event sometimes causes the slider to get hung up and not respond\n        // Keep only one per slider frame request\n        cancelAnimationFrame(range.updateValuesFrame);\n        range.updateValuesFrame = requestAnimationFrame(function () {\n            const backgroundLower = range.backgroundLower;\n\n            if (backgroundLower) {\n                let fraction = (value - range.min) / (range.max - range.min);\n\n                fraction *= 100;\n                backgroundLower.style.width = fraction + '%';\n            }\n        });\n    }\n\n    function updateBubble(range, value, bubble, bubbleText) {\n        requestAnimationFrame(function () {\n            const bubbleTrackRect = range.sliderBubbleTrack.getBoundingClientRect();\n            const bubbleRect = bubble.getBoundingClientRect();\n\n            let bubblePos = bubbleTrackRect.width * value / 100;\n            bubblePos = Math.min(Math.max(bubblePos, bubbleRect.width / 2), bubbleTrackRect.width - bubbleRect.width / 2);\n\n            bubble.style.left = bubblePos + 'px';\n\n            if (range.getBubbleHtml) {\n                value = range.getBubbleHtml(value);\n            } else {\n                if (range.getBubbleText) {\n                    value = range.getBubbleText(value);\n                } else {\n                    value = mapFractionToValue(range, value / 100).toLocaleString();\n                }\n                value = '<h1 class=\"sliderBubbleText\">' + value + '</h1>';\n            }\n\n            bubble.innerHTML = value;\n        });\n    }\n\n    EmbySliderPrototype.attachedCallback = function () {\n        if (this.getAttribute('data-embyslider') === 'true') {\n            return;\n        }\n\n        this.setAttribute('data-embyslider', 'true');\n\n        this.classList.add('mdl-slider');\n        this.classList.add('mdl-js-slider');\n\n        if (browser.edge) {\n            this.classList.add('slider-browser-edge');\n        }\n        if (!layoutManager.mobile) {\n            this.classList.add('mdl-slider-hoverthumb');\n        }\n        if (layoutManager.tv) {\n            this.classList.add('show-focus');\n        }\n\n        const topContainer = dom.parentWithClass(this, 'sliderContainer-settings');\n\n        if (topContainer && this.getAttribute('label')) {\n            const label = this.ownerDocument.createElement('label');\n            label.innerHTML = this.getAttribute('label');\n            label.classList.add('sliderLabel');\n            label.htmlFor = this.id;\n            topContainer.insertBefore(label, topContainer.firstChild);\n        }\n\n        const containerElement = this.parentNode;\n        containerElement.classList.add('mdl-slider-container');\n\n        let htmlToInsert = '';\n\n        htmlToInsert += '<div class=\"mdl-slider-background-flex-container\">';\n        htmlToInsert += '<div class=\"mdl-slider-background-flex\">';\n        htmlToInsert += '<div class=\"mdl-slider-background-flex-inner\">';\n\n        // the more of these, the more ranges we can display\n        htmlToInsert += '<div class=\"mdl-slider-background-upper\"></div>';\n\n        htmlToInsert += '<div class=\"mdl-slider-background-lower\"></div>';\n\n        htmlToInsert += '</div>';\n        htmlToInsert += '</div>';\n        htmlToInsert += '</div>';\n\n        htmlToInsert += '<div class=\"sliderBubbleTrack\"><div class=\"sliderBubble hide\"></div></div>';\n\n        containerElement.insertAdjacentHTML('beforeend', htmlToInsert);\n\n        this.sliderBubbleTrack = containerElement.querySelector('.sliderBubbleTrack');\n        this.backgroundLower = containerElement.querySelector('.mdl-slider-background-lower');\n        this.backgroundUpper = containerElement.querySelector('.mdl-slider-background-upper');\n        const sliderBubble = containerElement.querySelector('.sliderBubble');\n\n        let hasHideClass = sliderBubble.classList.contains('hide');\n\n        dom.addEventListener(this, 'input', function (e) {\n            this.dragging = true;\n\n            if (this.dataset.sliderKeepProgress !== 'true') {\n                updateValues.call(this);\n            }\n\n            const bubbleValue = mapValueToFraction(this, this.value) * 100;\n            updateBubble(this, bubbleValue, sliderBubble);\n\n            if (hasHideClass) {\n                sliderBubble.classList.remove('hide');\n                hasHideClass = false;\n            }\n        }, {\n            passive: true\n        });\n\n        dom.addEventListener(this, 'change', function () {\n            this.dragging = false;\n\n            if (this.dataset.sliderKeepProgress === 'true') {\n                updateValues.call(this);\n            }\n\n            sliderBubble.classList.add('hide');\n            hasHideClass = true;\n        }, {\n            passive: true\n        });\n\n        /* eslint-disable-next-line compat/compat */\n        dom.addEventListener(this, (window.PointerEvent ? 'pointermove' : 'mousemove'), function (e) {\n            if (!this.dragging) {\n                const bubbleValue = mapClientToFraction(this, e.clientX) * 100;\n\n                updateBubble(this, bubbleValue, sliderBubble);\n\n                if (hasHideClass) {\n                    sliderBubble.classList.remove('hide');\n                    hasHideClass = false;\n                }\n            }\n        }, {\n            passive: true\n        });\n\n        /* eslint-disable-next-line compat/compat */\n        dom.addEventListener(this, (window.PointerEvent ? 'pointerleave' : 'mouseleave'), function () {\n            sliderBubble.classList.add('hide');\n            hasHideClass = true;\n        }, {\n            passive: true\n        });\n\n        // HACK: iPhone/iPad do not change input by touch\n        if (browser.iOS) {\n            dom.addEventListener(this, 'touchstart', function (e) {\n                if (e.targetTouches.length !== 1) {\n                    return;\n                }\n\n                this.touched = true;\n\n                const fraction = mapClientToFraction(this, e.targetTouches[0].clientX);\n                this.value = mapFractionToValue(this, fraction);\n\n                this.dispatchEvent(new Event('input', {\n                    bubbles: true,\n                    cancelable: false\n                }));\n\n                // Prevent 'pointermove' and 'click' after 'touch*'\n                // FIXME: Still have some 'pointermove' and 'click' that bypass 'touchstart'\n                e.preventDefault();\n            }, {\n                capture: true\n            });\n\n            dom.addEventListener(this, 'touchmove', function (e) {\n                if (!this.touched || e.targetTouches.length !== 1) {\n                    return;\n                }\n\n                const fraction = mapClientToFraction(this, e.targetTouches[0].clientX);\n                this.value = mapFractionToValue(this, fraction);\n\n                this.dispatchEvent(new Event('input', {\n                    bubbles: true,\n                    cancelable: false\n                }));\n            }, {\n                passive: true\n            });\n\n            dom.addEventListener(this, 'touchend', function (e) {\n                const range = this;\n\n                setTimeout(function () {\n                    range.touched = false;\n\n                    range.dispatchEvent(new Event('change', {\n                        bubbles: true,\n                        cancelable: false\n                    }));\n                }, 0);\n            }, {\n                passive: true\n            });\n        }\n\n        if (supportsValueSetOverride) {\n            this.addEventListener('valueset', updateValues.bind(this, true));\n        } else {\n            startInterval(this);\n        }\n    };\n\n    /**\n     * Keyboard dragging timeout.\n     * After this delay \"change\" event will be fired.\n     */\n    const KeyboardDraggingTimeout = 1000;\n\n    /**\n     * Keyboard dragging timer.\n     */\n    let keyboardDraggingTimer;\n\n    /**\n     * Start keyboard dragging.\n     *\n     * @param {Object} elem slider itself\n     */\n    function startKeyboardDragging(elem) {\n        elem.keyboardDragging = true;\n\n        clearTimeout(keyboardDraggingTimer);\n        keyboardDraggingTimer = setTimeout(function () {\n            finishKeyboardDragging(elem);\n        }, KeyboardDraggingTimeout);\n    }\n\n    /**\n     * Finish keyboard dragging.\n     *\n     * @param {Object} elem slider itself\n     */\n    function finishKeyboardDragging(elem) {\n        clearTimeout(keyboardDraggingTimer);\n        keyboardDraggingTimer = undefined;\n\n        elem.keyboardDragging = false;\n\n        const event = new Event('change', {\n            bubbles: true,\n            cancelable: false\n        });\n        elem.dispatchEvent(event);\n    }\n\n    /**\n     * Do step by delta.\n     *\n     * @param {Object} elem slider itself\n     * @param {number} delta step amount\n     */\n    function stepKeyboard(elem, delta) {\n        startKeyboardDragging(elem);\n\n        elem.value = Math.max(elem.min, Math.min(elem.max, parseFloat(elem.value) + delta));\n\n        const event = new Event('input', {\n            bubbles: true,\n            cancelable: false\n        });\n        elem.dispatchEvent(event);\n    }\n\n    /**\n     * Handle KeyDown event\n     */\n    function onKeyDown(e) {\n        switch (keyboardnavigation.getKeyName(e)) {\n            case 'ArrowLeft':\n            case 'Left':\n                stepKeyboard(this, -this.keyboardStepDown || -1);\n                e.preventDefault();\n                e.stopPropagation();\n                break;\n            case 'ArrowRight':\n            case 'Right':\n                stepKeyboard(this, this.keyboardStepUp || 1);\n                e.preventDefault();\n                e.stopPropagation();\n                break;\n        }\n    }\n\n    /**\n     * Enable keyboard dragging.\n     */\n    EmbySliderPrototype.enableKeyboardDragging = function () {\n        if (!this.keyboardDraggingEnabled) {\n            this.addEventListener('keydown', onKeyDown);\n            this.keyboardDraggingEnabled = true;\n        }\n    };\n\n    /**\n     * Set steps for keyboard input.\n     *\n     * @param {number} stepDown step to reduce\n     * @param {number} stepUp step to increase\n     */\n    EmbySliderPrototype.setKeyboardSteps = function (stepDown, stepUp) {\n        this.keyboardStepDown = stepDown || stepUp || 1;\n        this.keyboardStepUp = stepUp || stepDown || 1;\n    };\n\n    function setRange(elem, startPercent, endPercent) {\n        const style = elem.style;\n        style.left = Math.max(startPercent, 0) + '%';\n\n        const widthPercent = endPercent - startPercent;\n        style.width = Math.max(Math.min(widthPercent, 100), 0) + '%';\n    }\n\n    function mapRangesFromRuntimeToPercent(ranges, runtime) {\n        if (!runtime) {\n            return [];\n        }\n\n        return ranges.map(function (r) {\n            return {\n                start: (r.start / runtime) * 100,\n                end: (r.end / runtime) * 100\n            };\n        });\n    }\n\n    EmbySliderPrototype.setBufferedRanges = function (ranges, runtime, position) {\n        const elem = this.backgroundUpper;\n        if (!elem) {\n            return;\n        }\n\n        if (runtime != null) {\n            ranges = mapRangesFromRuntimeToPercent(ranges, runtime);\n\n            position = (position / runtime) * 100;\n        }\n\n        for (const range in ranges) {\n            if (position != null) {\n                if (position >= range.end) {\n                    continue;\n                }\n            }\n\n            setRange(elem, range.start, range.end);\n            return;\n        }\n\n        setRange(elem, 0, 0);\n    };\n\n    EmbySliderPrototype.setIsClear = function (isClear) {\n        const backgroundLower = this.backgroundLower;\n        if (backgroundLower) {\n            if (isClear) {\n                backgroundLower.classList.add('mdl-slider-background-lower-clear');\n            } else {\n                backgroundLower.classList.remove('mdl-slider-background-lower-clear');\n            }\n        }\n    };\n\n    function startInterval(range) {\n        const interval = range.interval;\n        if (interval) {\n            clearInterval(interval);\n        }\n        range.interval = setInterval(updateValues.bind(range, true), 100);\n    }\n\n    EmbySliderPrototype.detachedCallback = function () {\n        const interval = this.interval;\n        if (interval) {\n            clearInterval(interval);\n        }\n        this.interval = null;\n        this.backgroundUpper = null;\n        this.backgroundLower = null;\n    };\n\n    document.registerElement('emby-slider', {\n        prototype: EmbySliderPrototype,\n        extends: 'input'\n    });\n\n/* eslint-enable indent */\n"]}